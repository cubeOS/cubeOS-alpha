;MIT Open License
;
;Copyright (c) 2012 Sasha Crofter

;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;
;
SET PC, __BOOT
;;;;;;;
; ENV ;
;;;;;;;
:env.cwds DAT 0
:env.fs DAT 0
:env.heap DAT 0
 ;;

; ; ; ;
;;;;;;;;
; BOOT ;
;;;;;;;;
;:# BOOT Loader
;:Initializes the kernel on startup
;:

;:### __BOOT
;:Invokes the boot loader
;:
;:1. Invoke *sv.init* to mount the screen at *videoRAM*.
;:2. Invoke *cat.mountSystem* to initialize the file system with arguments `0x8000, 0x810, 128`.
;:3. Invoke *p.init* to initialize the Dash Package Handler
;:4. Invoke *s.instance* to intialize the DASH Shell
;:
:__BOOT
JSR HWM

SET A, videoRAM
SET B, fontRAM
JSR sv.init ;set up boot screen and screen

SET A, 0x2000 ;heap location
SET B, 0x1000 ;length
SET C, 0x0100 ;block size (16 blocks)
JSR heap.init

;SHOULD SET VARIABLES TO LOCATION OF HEAP HEADER

JSR pih.init

SET A, 0x8000
SET B, 0x810
SET C, 128

JSR cat.mountSystem ;initialize FS

JSR p.init ;initialize DPH

SET A, 0
SET B, 6
HWI [HW.GenericClock]

SET A, 0
SET B, 0x0FFF
HWI [HW.Speaker]

SET A, 1
:__BOOT.wait
HWI [HW.GenericClock]
IFL C, 15
  SET PC, __BOOT.wait

SET A, 0
SET B, 0
HWI [HW.Speaker]

JSR s.instance ;initialize DASH Shell

SET PC, halt

:pTitle DAT 0x7563, 0x6562, 0x534f

:halt SUB PC, 1
 ;
 
;:### SYSTEM.RESTART
;:Clears all registers, drops interrupt queue
;:**under development**
;:
:SYSTEM.RESTART
SET A, 0
SET B, 0
SET C, 0
SET X, 0
SET Y, 0
SET Z, 0
SET I, 0
SET J, 0
SET SP, 0
IAS 0
SET PC, 0


;:### ext
;:Exits a subroutine with A set to 0 (`TRUE`)
;:To use, do `SET PC, ext` instead of `SET PC, POP` at the end of a subroutine
;:
:ext ; exit true
SET A, 0
SET PC, POP
 ;

;:### exf
;:Exits a subroutine with A set to 1 (`FALSE`)
;:To use, do `SET PC, exf` instead of `SET PC, POP` at the end of a subroutine
;:
:exf ; exit false
SET A, 1
SET PC, POP
 ;
 ;;
 

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;
; Monitor Preallocation ;
;;;;;;;;;;;;;;;;;;;;;;;;;
;:# Monitor Preallocation
;:Functions as a reserved spot for the font and video RAM of the LEM1802.
;:

;:### fontRAM
;:Contains the default font shown [here](http://github.com/cubeOS/cubeOS-alpha/raw/master/font/defaultFont.png).
;:

:fontRAM
DAT 0xb79e, 0x388e, 0x722c, 0x75f4, 0x19bb, 0x7f8f, 0x85f9, 0xb158, 0x242e, 0x2400, 0x082a, 0x0800, 0x0008, 0x0000, 0x0808, 0x0808, 0x00ff, 0x0000, 0x00f8, 0x0808, 0x08f8, 0x0000, 0x080f, 0x0000, 0x000f, 0x0808, 0x00ff, 0x0808, 0x08f8, 0x0808, 0x08ff, 0x0000, 0x080f, 0x0808, 0x08ff, 0x0808, 0x6633, 0x99cc, 0x9933, 0x66cc, 0xfef8, 0xe080, 0x7f1f, 0x0701, 0x0107, 0x1f7f, 0x80e0, 0xf8fe, 0x5500, 0xaa00, 0x55aa, 0x55aa, 0xffaa, 0xff55, 0x0f0f, 0x0f0f, 0xf0f0, 0xf0f0, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0x0000, 0x005f, 0x0000, 0x0300, 0x0300, 0x3e14, 0x3e00, 0x266b, 0x3200, 0x611c, 0x4300, 0x3629, 0x7650, 0x0002, 0x0100, 0x1c22, 0x4100, 0x4122, 0x1c00, 0x1408, 0x1400, 0x081c, 0x0800, 0xC020, 0x0000, 0x0808, 0x0800, 0x0040, 0x0000, 0x601c, 0x0300, 0x3e49, 0x3e00, 0x427f, 0xC000, 0x6259, 0x4600, 0x2249, 0x3600, 0x0f08, 0x7f00, 0x2745, 0x3900, 0x3e49, 0x3200, 0x6119, 0x0700, 0x3649, 0x3600, 0x2649, 0x3e00, 0x0024, 0x0000, 0xC024, 0x0000, 0x0814, 0x2200, 0x1414, 0x1400, 0x2214, 0x0800, 0x0259, 0x0600, 0x3e59, 0x5e00, 0x7e09, 0x7e00, 0x7f49, 0x3600, 0x3e41, 0x2200, 0x7f41, 0x3e00, 0x7f49, 0x4100, 0x7f09, 0x0100, 0x3e41, 0x7a00, 0x7f08, 0x7f00, 0x417f, 0x4100, 0x2040, 0x3f00, 0x7f08, 0x7700, 0x7f40, 0xC000, 0x7f06, 0x7f00, 0x7f01, 0x7e00, 0x3e41, 0x3e00, 0x7f09, 0x0600, 0x3e61, 0x7e00, 0x7f09, 0x7600, 0x2649, 0x3200, 0x017f, 0x0100, 0x3f40, 0x7f00, 0x1f60, 0x1f00, 0x7f30, 0x7f00, 0x7708, 0x7700, 0x0778, 0x0700, 0x7149, 0x4700, 0x007f, 0x4100, 0x031c, 0x6000, 0x417f, 0x0000, 0x0201, 0x0200, 0x8080, 0x8000, 0x0001, 0x0200, 0x2454, 0x7800, 0x7f44, 0x3800, 0x3844, 0x2800, 0x3844, 0x7f00, 0x3854, 0x5800, 0x087e, 0x0900, 0x4854, 0x3c00, 0x7f04, 0x7800, 0x047d, 0x0000, 0x2040, 0x3d00, 0x7f10, 0x6c00, 0x017f, 0x0000, 0x7c18, 0x7c00, 0x7c04, 0x7800, 0x3844, 0x3800, 0x7c14, 0x0800, 0x0814, 0x7c00, 0x7c04, 0x0800, 0x4854, 0x2400, 0x043e, 0x4400, 0x3c40, 0x7c00, 0x1c60, 0x1c00, 0x7c30, 0x7c00, 0x6c10, 0x6c00, 0x4c50, 0x3c00, 0x6454, 0x4c00, 0x0836, 0x4100, 0x0077, 0x0000, 0x4136, 0x0800, 0x0201, 0x0201, 0x0205, 0x0200


;:### videoRAM
;:Contains the cubeOS logo/splash screen, shown [here](https://github.com/cubeOS/cubeOS-alpha/raw/master/logo/cubeOSLogo.png).
;:
:videoRAM
DAT 0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
DAT 0,0,0xF01F,0xF01B,  0xF01B,0xF01B,0xF01B,0xF01B,  0xF01B,0xF01B,0xF01B,0xF01B,  0xF01B,0xF01B,0xF01B,0xF01B,  0xF01B,0xF01B,0xF01B,0xF01B,  0xF01B,0xF01B,0xF01B,0xF01B,  0xF01B,0xF01B,0xF01B,0xF01B, 0xF01B, 0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0xF057,0xF065,0,0,  0,0,0,0, 0,0,0,0,  0,0,0,0,  0,0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0,0xC01C,0xC01C,0,  0,0xC01C,0xC01C,0,  0,0,0,0,  0,0,0,0,  0,0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0xC01D,0xC01F,0xC01F,0xC01F,  0xC01F,0xC01F,0xC01F,0xC01E,  0,0,0,0,  0,0,0,0,  0,0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0,0xC01F,0x0C43,0x0C55,  0x0C42,0x0C45,0xC01F,0,  0,0,0,0,  0,0,0,0,  0,0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0,0,0xC01F,0xC01F,  0xC01F,0xC01F,0,0,  0,0,0,0,  0,0,0,0,  0,0xF01F, 0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0,0,0,0xC01B,  0xC01B,0,0,0,  0,0,0,0,  0,0,0,0,  0,0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0xF053,0xF063,0xF069,0xF065,  0xF06E,0xF063,0xF065,0,  0,0,0,0,  0,0,0,0, 0,0xF01F,0,0
DAT 0,0,0xF01F,0,  0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0xF01F,0,0
DAT 0,0,0xF01F,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01F,0,0
DAT 0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
 ;
 ;;

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT ; CAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# CAT
;:**CAT** is the default file system for cubeOS. It is based on the [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format.
;:
;:In order to act on a file or directory, it must be "opened." This copies the inode's contents to a temporary position (as provided by the program opening it.) Some of the subroutines below act on opened directories, so as to add links. When one is finished with a directory or file, one must "write" it back into its strip.
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**
;:

;:## High-level Commands
;:The high-level commands provide a smooth interface with the filesystem that can be used easily by modules and the rest of the operating system.
;:

;:### cat.getSector (currentSector, pathPointer)
;:Uses lower-level subroutines to parse either relative or absolute paths.
;:
;:**assumes there is open space at 0xa000**
;:
;:**returns** the start sector of the given file (via *pathPointer*,) or `0xffff` if it doesn't exist
;:
:cat.getSector
IFE [B], 0x2f ;if the first character in the path is "/"
  SET PC, cat.getSector.useAbs

:cat.getSector.call
SET C, B
SET B, 0xa000 ;THIS SHOULD NOT BE A STATIC VALUE, BUT RATHER IN THE HEAP
SET PC, cat.getSectorFromRelative

:cat.getSector.useAbs
SET A, 0 ;use the root directory as the starting point
ADD B, 1
SET PC, cat.getSector.call
 ;

;:## Low-level Commands
;:The low-level commands are used by the high level commands to provide fast and efficient access to the framework of the filesystem itself.
;:

;:### cat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a cat filesystem with the given *sectorSize*.
;:
;:**returns** location of first word in header
;:

;SHOULD KEEP TRACK OF WHERE FILESYSTEM IS SO IT CAN ADD NEW STRIPS AND DO SEARCHES

:cat.mountSystem
SET [env.fs], A

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A ;store location for retrieval at the end
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:cat.mountSystem.initHeader
STI [I], 0xC001 ;magic number, cat v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sector start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:cat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:cat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess bits to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, cat.mountSystem.initSectorMap.end

SUB B, 16
SET PC, cat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:cat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:cat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:cat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, cat.mountSystem.initSectorJoin.loop

:cat.mountSystem.initSectors
SET [A+4], I

:cat.mountSystem.initializeRoot
SET A, 0
SET B, 1
JSR cat.newInode

;TEST LINK
JSR cat.getSectorPointer ;get the location of the new inode at sector 0

SET PUSH, A
SET B, 1
SET C, temp.cat.testdir
JSR cat.newLink

SET A, POP
SET B, 2
SET C, temp.cat.testfile
JSR cat.newLink

SET A, 1
SET B, 1
JSR cat.newInode

JSR cat.getSectorPointer

SET B, 3
SET C, temp.cat.testfile2
JSR cat.newLink

SET PC, cat.mountSystem.exit

:temp.cat.testdir
DAT "TestDir", 0
:temp.cat.testfile
DAT "TestFile", 0
:temp.cat.testfile2
DAT "TestFile2", 0

:cat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### cat.open (stripStartSector, continuousMemoryLocation)
;:Obeying sector joins, copies the entire file or directory (including inode) specified by *stripStartSector* to *continuousMemoryLocation*.
;:
:cat.open
SET PUSH, I
SET PUSH, A

JSR cat.getSectorPointer ;only modifies A
SET I, [A+3] ;set I to the content length
ADD I, 4 ;add the inode length

SET A, POP

:cat.open.loop
SET PUSH, A ;store A for looping

JSR cat.getJoinedSector

IFE A, 0
  SET PC, cat.open.exit

SET C, [env.fs]
SET C, [C+5]

SUB I, C ;subtract from the total length
;rather than subtracting every time, one could do MOD and use the remainder for copying the very end of the strip

JSR cat.getSectorPointer ;only modifies A; get literal memory location

JSR typ.pCopy ;copy the sector
SET B, A ;put the copy continue location in B

SET A, POP
JSR cat.getJoinedSector
SET PC, cat.open.loop

:cat.open.exit
SET A, POP
JSR cat.getSectorPointer

SET C, I
JSR typ.pCopy

SET I, POP
SET PC, POP
 ;

;:### cat.write (inputPointer, sectorNumber)
;:Obeying sector joins, copies the entire contents of an open file at *inputPointer* to the sector at *sectorNumber*, linking new sectors as needed and unlinking old ones if they become unnecessary.
;:**under development**
;:
:cat.write
SET PUSH, I
SET PUSH, J
SET PUSH, X

SET J, [env.fs]
SET J, [J+5] ;set C to the size of a sector

SET I, [A+3] ;set A to the size of the input
ADD I, 4 ;include the size of the inode

SET PUSH, I ;store the size of the input for later

DIV I, J ;set I to the number of sectors needed for the whole file
ADD I, 1 ;DIV rounds down ;FIND A RELIABLE WAY TO DO THIS

SET X, A ;make X the storage place for the current input index

:cat.write.loop
IFE I, 1
  SET PC, cat.write.exit

SET PUSH, B ;store the current sector number

SET A, B
JSR cat.getSectorPointer ;get the location of the sector in memory
SET B, A


SET A, X ;set A to the location for input in the copy
SET C, J 
JSR typ.pCopy ;returns the output location

ADD X, J ;make X the location of the remaining part of the file
SUB I, 1 ;reduce the number of remaining sectors to copy by 1

SET A, POP ;restore the number of the sector that was just written to
JSR cat.linkNewSector ;link a new sector if one is not already linked

SET B, A ;set B to the next sector to write to

SET PC, cat.write.loop

:cat.write.exit
SET C, POP ;restore the size of the input
MOD C, J ;make C the leftover size

SET A, B
JSR cat.getSectorPointer
SET B, A

SET A, X
JSR typ.pCopy

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### cat.linkNewSector (sectorNumber)
;:If **sectorNumber** does not link to another sector, link the first open sector to it.
;:
;:**modifies** A <br />
;:**returns** the sector number joined
;:
:cat.linkNewSector
SET PUSH, B
SET B, [env.fs]
SET B, [B+3]

ADD B, A
IFN [B], 0 ;if the sector is already linked, just return with that value.
  SET PC, cat.linkNewSector.exit

;if it's not already linked, do the following

JSR cat.getOpenSector ;modifies A; get the first open sector from the bitmap
JSR cat.markSectorUsed ;returns the sector; mark that sector used

SET [B], A ;link the new sector

:cat.linkNewSector.exit
SET A, [B]
SET B, POP
SET PC, POP
 ;

;:### cat.getJoinedSector (sectorNumber)
;:**modifies** A <br />
;:**returns** the sector joined to *sectorNumber*, or **0** if unjoined or unused
;:
:cat.getJoinedSector
SET PUSH, B
SET B, [env.fs] ;sector joins start
SET B, [B+3]
ADD B, A
SET A, [B]
SET B, POP
SET PC, POP
 ;

;:### cat.getOpenSector ()
;:Finds the first open sector in the filesystem. **Does not detect when the system is full.**
;:
;:**modifies** A
;:**returns** sector number
;:
:cat.getOpenSector
SET PUSH, B
SET PUSH, C
SET PUSH, I

SET A, [env.fs]
SET B, [A+2] ;starting location
;SET C, [A+3] ;ending location

:cat.getOpenSector.wordloop
SET A, [B]
SET C, 0x8000 ;0b1000 0000 0000 0000

:cat.getOpenSector.bitloop
IFC C, A ;if C & A == 0
  SET PC, cat.getOpenSector.exit

ADD I, 1

IFE C, 0x0001 ;0b0000 0000 0000 0001
  SET PC, cat.getOpenSector.nextWord ;get the next word in the map

SHR C, 1
SET PC, cat.getOpenSector.bitloop

:cat.getOpenSector.nextWord
ADD B, 1
SET PC, cat.getOpenSector.wordloop

:cat.getOpenSector.exit
SET A, I

SET I, POP
SET C, POP
SET B, POP
SET PC, POP
 ;

;:### cat.getSectorPointer (sector)
;:**modifies** A
;:**returns** a pointer to the location of the given sector in memory
;:
:cat.getSectorPointer
SET PUSH, B
SET B, [env.fs]
MUL A, [B+5] ;multiply by sector size
ADD A, [B+4] ;add sector offset
SET B, POP
SET PC, POP
 ;

;:### cat.newInode (sector, type)
;:Creates a new inode of *type* and length 0 at *sector*. It also marks the corresponding sector in sector map as used.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:
;:**modifies** A, B <br />
;:**returns** the sector of the inode

:cat.newInode
SET PUSH, C
SET PUSH, A ;store A for returning
JSR cat.getSectorPointer ;make A a pointer to the start of that sector

SET [A], B
SET [A+1], 0 ;the number of links pointing to the inode
SET [A+2], 0 ;reserved high order word content size
SET [A+3], 0 ;low order word content size

SET A, PEEK
SHR A, 4 ;divide by 16

SET B, [env.fs]
SET B, [B+2] ;set B to the location of the sector map

ADD B, A ;set B to the location of the relavent word of the sector map

SET A, PEEK
AND A, 0x000f ;set A to the index of the relevant bit

SET C, 0x8000 ;0b1000 0000 0000 0000
SHR C, A ;make the relevant bit of C 1

BOR [B], C ;set the relevant bit of B to 1

SET A, POP
SET C, POP
SET PC, POP
 ;

;:### cat.rmInode (sector)
;:Marks *sector* unused in the sector map, <strike>unlinks the rest of the strip</strike>, and marks its inode unused.
;:
;:**modifies** A <br />
;:**returns** *sector*
;:
:cat.rmInode
SET PUSH, C
SET PUSH, B
SET PUSH, A ;store A for returning

JSR cat.getSectorPointer ;get the sector in memory
SET [A], 0 ;mark the inode unused
SET [A+3], 0 ;set the content length to zero

SET A, PEEK
JSR cat.freeStrip

SET A, POP
SET B, POP
SET C, POP
SET PC, POP
 ;

;:### cat.freeStrip (startSector)
;:Unlinks all of the sectors in a strip and marks them each as free
;:
:cat.freeStrip
SET C, [env.fs]
SET C, [C+3] ;set I to the sector joins start

:cat.freeStrip.loop
SET B, C
ADD B, A ;set B to the location of the sector's join

JSR cat.markSectorUnused ;marks the sector unused in the bitmap
;without changing registers

IFE [B], 0
  SET PC, POP

SET A, [B]
SET [B], 0
SET PC, cat.freeStrip.loop
 ;

;:### cat.markSectorUsed (sector)
;:Marks a sector used in the bitmap.
;:
;:**modifies** A <br />
;:**returns** *sector*
;:
:cat.markSectorUsed
SET PUSH, C
SET PUSH, B
SET PUSH, A ;store for reusage

SHR A, 4 ;divide by 16

SET B, [env.fs]
SET B, [B+2] ;set B to the location of the sector map

ADD B, A ;set B to the location of the relavent word of the sector map

SET A, PEEK
AND A, 0x000f ;set A to the index of the relevant bit

SET C, 0x8000 ;0b1000 0000 0000 0000
SHR C, A ;make the relevant bit of C 1

BOR [B], C ;set the relevant bit of B to 0
SET A, POP
SET B, POP
SET C, POP
SET PC, POP
 ;

;:### cat.markSectorUnused (sector)
;:Marks a sector unused in the bitmap.
;:
;:**modifies** A <br />
;:**returns** *sector*
;:
:cat.markSectorUnused
SET PUSH, C
SET PUSH, B
SET PUSH, A ;store for reusage

SHR A, 4 ;divide by 16

SET B, [env.fs]
SET B, [B+2] ;set B to the location of the sector map

ADD B, A ;set B to the location of the relavent word of the sector map

SET A, PEEK
AND A, 0x000f ;set A to the index of the relevant bit

SET C, 0x8000 ;0b1000 0000 0000 0000
SHR C, A ;make the relevant bit of C 1
XOR C, 0xffff ;negate C, so the relevant bit is 0

AND [B], C ;set the relevant bit of B to 0
SET A, POP
SET B, POP
SET C, POP
SET PC, POP
 ;


;:### cat.newLink (directoryPointer, targetStripStartSector, namePointer)
;:Creates a new link under the given sector, extending the length of the inode automatically <strike>and overflowing to the next open sector (updating sector usage and linking) if necessary</strike>.
;:The first word is the *targetStripStartSector*, and the remaining fifteen words are copied literally <strike>(maximum length fourteen)</strike> from the null-terminated word at *namePointer*.
;:**returns** 0 if successful, and 1 if the given sector does not contain a directory
;:
:cat.newLink
IFN [A], 1 ;if the sector does not contain a directory
  SET PC, exf ;exit false

SET PUSH, A ;store A for later

ADD A, [A+3] ;add the length of the existing links
ADD A, 4 ;add the length of the inode

SET [A], B ;set the link target
ADD A, 1
SET B, A ;B is now the location to copy to

SET A, C
JSR typ.ffz ;find the first 0 (only modifies A)

;IF LENGTH IS GREATER THAN CAN BE SUPPORTED, DISCARD THE OTHER VALUES AND EXIT FALSE

SET PUSH, C ;store C
SET PUSH, B ;store B


SET B, A ;B is the length argument
SET A, C ;A is the location argument

JSR crp.sum ;get the checksum of the string

SET B, POP ;restore output location
SET [B], A ;set the second word in the link to the checksum
ADD B, 1 ;increment location fittingly

SET A, POP
JSR typ.cCopy ;SHOULD IMPOSE MAXIMUM LENGTH

SET A, POP
ADD [A+3], 16 ;add the length of the link (always 16) to the length of the inode
SET PC, ext ;exit successful
 ;

;:## Low-Level Parsing Commands
;:

;:### cat.getSectorFromRelative (currentSector, spaceForOpenFile, relativePath)
;:
;:
:cat.getSectorFromRelative
SET PUSH, I
SET PUSH, J

SET I, C

SET PUSH, A ;store A

SET A, C
JSR typ.ffz ;modifies A

SET J, A ;make J the length
ADD J, C ;make J the ending location for the path

:cat.getSectorFromRelative.sepArgs
IFE [C], 0x2f ;if the current character is a slash
  SET [C], 0 ;set it to 0

ADD C, 1
IFN C, J
  SET PC, cat.getSectorFromRelative.sepArgs

SET A, POP ;restore A
SET PUSH, B ;for recurring usage

:cat.getSectorFromRelative.recurse
 ;A will be the sector to read from
SET B, PEEK

JSR cat.open

SET B, I
SET A, PEEK ;restore memory location
JSR cat.getSectorFromSingleRelative

IFE A, 0xffff
  SET PC, cat.getSectorFromRelative.found

SET PUSH, A

SET A, I
JSR typ.ffz ;get first zero ;only modifies A
ADD A, I ;make a location, not a length
SET I, A

SET A, POP

IFE I, J
  SET PC, cat.getSectorFromRelative.found
ADD I, 1 ;go to beginning of next word

SET PC, cat.getSectorFromRelative.recurse

:cat.getSectorFromRelative.found

SET C, POP
SET J, POP
SET I, POP
SET PC, POP


;:### cat.getSectorFromSingleRelative (currentOpenDirectoryPointer, relativePath)
;:Gets the sector pointed to by the link in *currentOpenDirectoryPointer* by *relativePath*. This is **not recursive**. *relativePath* is considered terminated by a slash null.
;:
;:**returns** the target sector if found, or `0xffff` if not
;:
:cat.getSectorFromSingleRelative
SET PUSH, A ;store A
SET PUSH, B ;store B

SET A, B
JSR typ.ffz ;get the length of the relative path

SET B, A
SET A, POP
JSR crp.sum ;get the sum of the relative path

SET B, A ;set B to the sum

SET A, POP ;restore the directory pointer
SET C, [A+3] ;make C the content length
ADD A, 5 ;make A the location of the first link's sum

:cat.getSectorFromSingleRelative.loop
IFE [A], B
  SET PC, cat.getSectorFromSingleRelative.found

ADD A, 16
SUB C, 16
IFA C, 0
  SET PC, cat.getSectorFromSingleRelative.loop

SET A, 0xffff
SET PC, POP

:cat.getSectorFromSingleRelative.found
SET A, [A+0xffff] ;set A to the sector that is pointed to by A-1
SET PC, POP

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PINKIEPIE ; Interrupt Handler ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;: **PinkiePie Interrupt Handler** is cubeOS's integrated software interrupt handler.
;:


;:## Software Interrupts
;:A software interrupt is called in assembly by `INT a`, where `a` is a "message." Upon executing an interrupt, `PC` and `A` are pushed to the stack and replaced by the value in the register `IA` and the message, respectively. This forces the DCPU to begin executing code at whatever address `IA` was set to beforehand. That code can then exit by doing, after restoring other registers, `RFI 0`, which disables interrupt queueing, pops `A` from the stack, then pops `PC` from the stack. That will allow the DCPU to resume the code it was executing before the interrupt was called.
;:In large operating environments, it makes sense to set `IA` to a constant value at the start of operation, before any interrupts are called. This allows for *interrupt handlers*, which are usually provided by operating systems. The start address of the interrupt handler is placed in `IA`, so it is invoked whenever an interrupt is called. This allows it to handle interrupts consistently, as based on the message.
;:It also allows software not included in the kernal (and therefore not privvy to labels,) to make function calls defined by the interrupt handler. Furthermore, advanced enough interrupt handlers can allow an operating system to support multitasking.
;:

;:## Initialization
;:To initialize PinkiePie, use `pih.init`. Changes to IA can be reset by performing this call again.
;:
;:### pih.init
;:Does `IAS pih` to direct any interrupts to the interrupt handler.
;:
:pih.init
IAS pih
SET PC, POP
 ;
 
;:## Interrupt Handler
;:The interrupt handler is located at the label `pih`. The subroutine `pih.init` makes this the active interrupt handler.
;:PinkiePie's interrupt handling process is as follows.
;:
;:1. Trigger interrupt queueing with `IAQ 1`
;:2. Drops the interrupt and returns with `RFI` if the message is greater than 128.
;:3. Looks up the message in `pih.cmdtable`.
;:4. If the value is `0xFFFF`, then return with `RFI`.
;:5. Push `B` and `C` to the stack, so they will be preserved.
;:6. `JSR` to the value returned by the table.
;:7. Pop `C` and `B` from the stack, and do `RFI`.
;:
;:If the interrupt is actually an API call, (i.e. A call made to the OS with arguments.) then the receiving subroutine must pop arguments from the stack in order to retrieve them. This is necessary, but **be careful**.
;:

:pih
IAQ 1 ;trigger interrupt queueing

IFG A, 128 ;If the message is too great
  RFI 1

SET A, [A+pih.cmdtable]

IFE A, 0xffff
  RFI 1

SET PUSH, B
SET PUSH, C

JSR A

SET C, POP
SET B, POP
RFI 1

;:### Messages
;:Messages 0-63 are reserved for calls reagarding the OS.
;:Messages 64-127 are reserved for programs.


:pih.cmdtable
DAT 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff

:pihExit
SET C, POP
SET B, POP
RFI 0
 ;

;:### pih.newMsg (location)
;:Finds the first unused message greater than or equal to 64, but less than or equal to 127. It then makes *location* the location to jump to when that interrupt is triggered.
;:
;:**returns** the first open message
;:
:pih.newMsg
SET B, 64

:pih.newMsg.findOpen
IFE [pih.cmdtable + B], 0xffff
  SET PC, pih.newMsg.found
ADD B, 1
SET PC, pih.newMsg.findOpen

:pih.newMsg.found
SET [pih.cmdtable + B], A
SET A, B
SET PC, POP

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;
; SIMVID ; Video Manager ;
;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.scrnLoc DAT 0
:v.scrnEnd DAT 0
:v.scrnHeight DAT 12
:v.scrnWidth DAT 32

;:### sv.init (videoRAMPointer, fontRAMPointer)
;:Maps the screen's font to *fontRAMPointer* and the screen's video ram to *videoRAMPointer* in that order.
;:
:sv.init

SET PUSH, A
SET A, 1
HWI [HW.LEM1802] ;MEM_MAP_FONT

SET B, POP
SET A, 0
HWI [HW.LEM1802] ;MEM_MAP_SCREEN

SET [v.scrnLoc], B
ADD B, 0x180
SET [v.scrnEnd], B
SET PC, POP
 ;
 
;:### sv.write (inputPointer, outputPointer)
;:Writes ASCII to the screen using special characters to act as directives. (This does not perform preprocessing such as translating normal ASCII into those special characters.) Special characters are as follows.
;:**returns** the location of the null following the written text
;:
;:#### Color `0x01`
;:Substitutes the first nine bits of every word following this with the first nine bits of this word.
;:
;:
;:
:sv.write
IFC [A], 0x007F ;if the last 7 bits are 0b0000 000
  SET PC, sv.write.exitEarly ;exit early

SET PUSH, I
SET PUSH, J

SET I, A
SET J, B
SET [sv.write.v.color], 0xF000 ;default to white on black

:sv.write.loop
SET A, [I]
AND A, 0x007F

IFE A, 0x01
  SET PC, sv.write.s.color

BOR A, [sv.write.v.color]

STI [J], A ;set the destination to the processed source and increment destination pointer and source pointer

IFN [I], 0
  SET PC, sv.write.loop
  
SET [J], [I] ;write the terminating null

SET A, J
SET J, POP
SET I, POP
SET PC, POP

:sv.write.exitEarly
SET [B], 0x0000 ;make the first word in the output null
SET A, B ;return the index that sv.write would have written to
         ;if there had been content
SET PC, POP

:sv.write.s.color
SET [sv.write.v.color], [I]
AND [sv.write.v.color], 0xFF80 ;first 9 bits
ADD I, 1 ;increment the source, but not the destination
SET PC, sv.write.loop

:sv.write.v.color DAT 0
 ;
 
:sv.clear
SET PUSH, I
SET PUSH, J

SET I, [v.scrnLoc]

:sv.clear.loop
STI [I], 0

IFL I, [v.scrnEnd]
  SET PC, sv.clear.loop

SET J, POP
SET I, POP
SET PC, POP
 ;

:sv.getLoc ; (xOffset, yOffset)
IFL A, [v.scrnWidth]
  IFL B, [v.scrnHeight]
    SET PC, sv.getLoc.loc ;if onscreen, continue
SET PC, exf

:sv.getLoc.loc
MUL B, [v.scrnWidth] ;make yOffset a line index
ADD A, B              ;combine them
ADD A, [v.scrnLoc]    ;make the index an index onscreen
SET PC, POP           ;return in A
 ;

:sv.autoScroll ; () does not modify registers
SET PUSH, X

SET X, [v.scrnEnd]
SUB X, [v.scrnWidth]

IFE [X], 0
  SET PC, sv.autoScroll.ex

SET PUSH, I
SET PUSH, J
SET I, [v.scrnLoc]
SET J, I
ADD J, [v.scrnWidth]

:sv.autoScroll.loop
STI [I], [J]
IFN J, X
  SET PC, sv.autoScroll.loop

SET X, J
:sv.autoScroll.looplast
STI [I], [X]
SET [X], 0
ADD X, 1
IFG X, [v.scrnEnd]
  SET PC, sv.autoScroll.subex
SET PC, sv.autoScroll.looplast

:sv.autoScroll.subex
SET J, POP
SET I, POP

:sv.autoScroll.ex
SET X, POP
SET PC, POP
 ;

:sv.scrollUp
SET PUSH, I
SET PUSH, J

SET I, [v.scrnLoc]
SET J, I
ADD J, [v.scrnWidth]

:sv.scrollUp.loop
STI [I], [J]
IFL J, [v.scrnEnd]
  SET PC, sv.scrollUp.loop

:sv.scrollUp.clearLast
SET I, [v.scrnEnd]
SUB I, [v.scrnWidth]

:sv.scrollUp.clearLast.loop
STI [I], 0
IFL I, [v.scrnEnd]
  SET PC, sv.scrollUp.clearLast.loop

SET J, POP
SET I, POP
SUB I, [v.scrnWidth] ;adjust I for caller, hopefully
SET PC, POP
 ;
 
:sv.getNewLine ; (currentLoc)
SET PUSH, I
SET I, [v.scrnLoc]
JSR sv.autoScroll
SET PC, sv.getNewLine.loop.sub

:sv.getNewLine.loop
ADD I, [v.scrnWidth]

:sv.getNewLine.loop.sub
IFG A, I ;exit successful if line scrnindex >= currentindex
  SET PC, sv.getNewLine.loop

IFE I, [v.scrnEnd]
  SUB I, [v.scrnWidth]

SET A, I
SET I, POP
SET PC, POP
 ;
 ;;

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TASKER ; Process Manager ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.tusk.IDiterator DAT 1000 ;the iterator through which to get unique IDs
:v.tusk.runPID DAT 0 ;the ID of the process that is currently running

:v.tusk.PIDloc DAT tusk.PIDs

;:### tusk.newProcess
;:Registers a new process of unique ID. Adds the process id to the table at *v.tusk.PIDloc*.
;:
;:**under development**
;:
:tusk.newProcess

:tusk.PIDs ;64 open spaces
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TYPER ; Data and String Handler ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;:### typ.ffw (pointer, word)
;:**F**inds the **f**irst **w**ord matching *word* after *pointer*, and returns the number of words between *pointer* and that *word*.
;:
;:**modifies** A
;:
:typ.ffw
SET PUSH, A

:typ.ffw.loop
IFE [A], B
  SET PC, typ.ffw.exit

ADD A, 1
SET PC, typ.ffw.loop

:typ.ffw.exit
SUB A, POP
SET PC, POP
 ;

;:### typ.ffz (pointer)
;:**F**inds the **f**irst **z**ero after *pointer*, and returns the number of words between *pointer* and that zero.
;:
;:**modifies** A
;:
:typ.ffz
SET PUSH, B
SET B, 0
JSR typ.ffw ;find first word matching 0
SET B, POP
SET PC, POP

;:### typ.htoascii (hextet, outputPointer)
;:Converts *hextet* (a 16-bit unsigned integer) to ASCII, and writes that ASCII to *outputPointer*. Always produces four ASCII characters.
;:
;:**returns** the location following the last character of the ASCII writing.
;:
:typ.htoascii
SET PUSH, I
SET I, 4 ;counter for how many times to shift the hextet

:typ.htoascii.lookup
SET C, 0xf000
AND C, A
SHR C, 12
SET [B], [typ.htoascii.table + C]

SHL A, 4
SUB I, 1
ADD B, 1

IFN I, 0
  SET PC, typ.htoascii.lookup

SET I, POP
SET A, B
SET PC, POP

:typ.htoascii.table
DAT 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39 ; "0" - "9"
DAT 0x61, 0x62, 0x63, 0x64, 0x65, 0x66 ; "a" - "f"

;:### typ.cCopy (inputPointer, outputPointer)
;:Copies the null-terminated string at *inputPointer* to *outputPointer*.
;:**returns** the location following the last character of the copy at the *outputPointer* location
;:

:typ.cCopy
SET PUSH, I
SET PUSH, J
SET I, A
SET J, B

:typ.cCopy.loop
IFE [I], 0
  SET PC, typ.cCopy.exit

STI [J], [I]
SET PC, typ.cCopy.loop

:typ.cCopy.exit
SET [J], 0
SET A, J
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### typ.pCopy (inputPointer, outputPointer, length)
;:Copies data of *length* from *inputPointer* to *outputPointer*.
;:**returns** a pointer to the word following the last output word
;:
:typ.pCopy
SET PUSH, I
SET PUSH, J

SET I, A
SET J, B
ADD C, A

:typ.pCopy.loop
IFE I, C
  SET PC, typ.pCopy.exit

STI [J], [I]
SET PC, typ.pCopy.loop

:typ.pCopy.exit
SET A, J
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### typ.cUnpack (inputPointer, outputPointer)
;:Reads a packed (`0b0YYY YYYY 0XXX XXXX`) null-terminated at *inputPointer*(A) and outputs an unpacked (`0b0000 0000 0XXX XXXX`) string at *outputPointer*(B).
;:

:typ.cUnpack
SET PUSH, I
SET I, A
SET C, B

:typ.cUnpack.loop
IFE [I], 0
  SET PC, typ.cUnpack.exit
 
set push, [I]
and [I], 0x007F
IFE [I], 0
  SET PC, typ.cUnpack.exit
set [C], [I]
set [I], pop
add c, 1
set push, [I]
shr [I], 8
and [I], 0x007F
IFE [I], 0
  SET PC, typ.cUnpack.exit
set [C], [I]
set [I], pop
ADD I, 1
add C, 1
SET PC, typ.cUnpack.loop

:typ.cUnpack.exit
set [c], 0
SET I, POP
SET PC, pop

;:### typ.pPack (inputLocation, inputLength, outputLocation)
;:Reads an unpacked (`0b0000 0000 0XXX XXXX`) string from *inputLocation* of *inputLength* and outputs a packed (`0b0YYY YYYY 0XXX XXXX`) little-endian style string at *outputLocation*.
;:

:typ.pPack
SET PUSH, I
SET PUSH, X
SET PUSH, Y
SET PUSH, Z

SET Z, 0x007F
SET I, A
ADD B, A


:typ.pPack.loop
STI X, [I]
AND X, Z
SET [C], X
STI X, [I]
AND X, Z
SHL X, 8
XOR [C], X

ADD C, 1
IFL I, B
  SET PC, typ.pPack.loop

SET Z, POP
SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;

;:### typ.pUnpack (inputPointer, inputLength, outputPoiner)
;:Reads a packed (`0b0YYY YYYY 0XXX XXXX`) in little-endian at *inputPointer* of *inputLength* and outputs an unpacked (`0b0000 0000 0XXX XXXX`) string at *outputPointer*.
;:

:typ.pUnpack
SET PUSH, I
SET PUSH, X
SET PUSH, Y
SET PUSH, Z

SET I, C
ADD B, A
SET Z, 0x007F
SET Y, 0x7F00

:typ.pUnpack.loop
SET X, [A]
AND X, Z
STI [I], X

SET X, [A]
AND X, Y
SHR X, 8
STI [I], X

ADD A, 1
IFL A, B
  SET PC, typ.pUnpack.loop

SET A, I ;return in A

SET Z, POP
SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;
 ;;

; ; ; ;
;;;;;;;;;;;;;;;;;;
; KeyboardDaemon ;
;;;;;;;;;;;;;;;;;;
;:An instance of KeyboardDemon should be registered to any process that requires detection of keypresses. It requests an interrupt value from the operating system, and, when it detects that interrupt, writes the pressed key, if it is ASCII, to the location registered on its instantiation. (That location is, of course, incremented.)
;:


:v.kd.writePointer DAT 0

;:### kd.init (writePointer)
;:
:kd.init



; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HWMAN ; Hardware Manager ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;:The Hardware Manager is designed to be run to place a layer of abstraction between the software and connected hardware. HWM detects known hardware and maps their port numbers to memory locations, which are accessible through labels.
;:For example, to send a hardware interrupt to a connected LEM1802, one might normally use the command `HWI 0`, or `HWI 1`. This might change between emulators and ingame, however. HWM allows such syntax as `HWI [LEM1802]`.
;:
;:## Supported Hardware
;:*Items marked with an asterisk do not have intialization routines called automatically.
;:- *[Generic Clock](http://0x10c.com/highnerd/rc_1/clock.txt)
:HW.GenericClock DAT 0xffff
;:- *[LEM1802](http://0x10c.com/highnerd/rc_1/lem1802.txt)
:HW.LEM1802 DAT 0xffff
;:- *[Generic Keyboard](http://0x10c.com/highnerd/rc_1/keyboard.txt)
:HW.GenericKeyboard DAT 0xffff
;:- *[Speaker](http://bitbucket.org/benedek/dcpu-16/src/477043e85337/doc/speaker.txt)
:HW.Speaker DAT 0xffff
;:- *[HMD2043](https://gist.github.com/2516406)
:HW.HMD2043
;:
;:## Subroutines
;:

;:### HWM
;:Maps the ports of all recognized hardware to specific points in memory, which are accessible through labels. Upon recognizing a piece of hardware, it will map it to a memory location and do an automatic `JSR` to a label of the form `HWinit.x`, where *x* is the name of the hardware recognized in either full form (`HWinit.LEM1802`) or definition camel case (`HWinit.GenericClock`) if the name of the hardware cannot be represented by labels in its full form.
;:
:HWM
JSR pushReg

HWN I ;I is the number of attached devices
SET J, 0 ;J will be the iterator

:HWM.loop
HWQ J

IFE A, 0xf615
  IFE B, 0x7349
    SET [HW.LEM1802], J

IFE A, 0xb402
  IFE B, 0x12d0
    SET [HW.GenericClock], J
    
IFE A, 0x7406
  IFE B, 0x30cf
    SET [HW.GenericKeyboard], J

IFE A, 0x0001
  IFE B, 0x0206
    SET [HW.Speaker], J

IFE A, 0x4cae
  IFE B, 0x74fa
    SET [HW.HMD2043], J

ADD J, 1

IFN I, J
  SET PC, HWM.loop
  
SET PC, popReg
 ;
 
;:### HWF.LEM1802
;:Finds the LEM1802 in as few cycles as possible and sets the memory location at the label *LEM1802* to its port number without mapping other hardware. This is intended to be run at boottime in order to quickly start the monitor and display a boot screen.
;:**Under development**
;:

;:### pushReg
;:Pushes all registers to the stack.
;:
:pushReg
SET [pushReg.ReturnLocation], POP
SET PUSH, A
SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I
SET PUSH, J
SET PC, [pushReg.ReturnLocation]
:pushReg.ReturnLocation DAT 0 ;needed in order to return after pushing values
 ;

;:### popReg
;:Pops all registers from the stack, then pops PC from the stack. **This must be called by `SET PC, popReg`.** Otherwise, the registers will be popped incorrectly.
;:
:popReg
SET J, POP
SET I, POP
SET Z, POP
SET Y, POP
SET X, POP
SET C, POP
SET B, POP
SET A, POP
SET PC, POP
 ;

; ; ; ;
;RETURNS INCORRECT VALUE IF DOING HASHGET ON AN UNPRESENT VALUE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DATALIB ; Data Managing Library ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:DataLib is a library for managing arbitrary amounts of data with relative speed and efficiency.
;:

;:## Hash Table
;:Subroutines for creating and searching hash tables, which are sorted tables that store values under names
;:

;:### dl.makeHashTable (headerPointer, indicies, startingLength)
;:Creates the header for a hashTable at *headerPointer* with *indicies* as the target number of indicies for the hashTable. The total length of the hashTable is `2 * indicies + 4`, which includes the header, the lookup portion of the table, and the value portion of the table. *length* is not the total length of the table, but rather the number of occupied indicies.
;:**returns** *headerPointer*
;:
:dl.makeHashTable
SET [A], 0x5468 ;"hT" magic number
SET [A+1], B ;indicies
SET [A+2], C ;length
SET [A+3], 0 ;reserved
SET PC, POP
 ;

;:### dl.hashGet (searchTerm, hashTablePointer)
;:Searches the hash table at *hashTablePointer* for *searchTerm* in the lookup portion of it. It returns the value in the value portion associated with the searchTerm.
;:
;:**returns** value associated by the hash table with *searchTerm*, or 1 if it could not be found
;:**development version** 
;:
:dl.hashGet
SET PUSH, [B+1] ;store the number of indicies

SET C, [B+2] ;length
ADD B, 4 ;location
JSR dl.searchValTable

IFE A, 1
  SET PC, dl.hashGet.exf

ADD A, POP ;make A an index in the value table
SET A, [A] ;return the value, rather than the index
SET PC, POP

:dl.hashGet.exf
;A is 1
SET B, POP
SET PC, POP
 ;

;:### dl.hashInsert (lookupValue, insertValue, hashTablePointer)
;:Inserts *lookupValue* in a sorted way in the lookup portion of the hashTable at *hashTablePointer* and *insertValue* in an unsorted way at the same index in the value portion of the table. This is designed to work very well with the 16-bit hashing algorithm crp.dsHash.
;:
;:**under development**
;:
:dl.hashInsert
SET PUSH, B ;store *insertValue*
SET PUSH, [C+1] ;store *indicies* from header
SET PUSH, C ;store pointer to header

SET B, C
ADD B, 4 ;start of sortedTable (for lookups)
SET C, [C+2] ;length of sortedTable

JSR dl.sortedInsert

SET C, POP
ADD [C+2], 1 ;add one to the length

ADD A, POP ;retrieve *indicies* from stack

SET B, A
SET A, POP ;retrieve *insertValue* from stack

SET PC, dl.unsortedInsert
 ;

;:## Sorted Table
;:Subroutines for creating and searching sorted tables
;:

;:### dl.sortedInsert (insertValue, tableLocation, tableLength)
;:Inserts *insertValue* into the sorted table at *tableLocation* of *tableLength*, maintaining the sortedness of the table.
;:
;:**returns** location of insert<strike>, or 1 if the value is already present in the table</strike>
;:
:dl.sortedInsert
SET PUSH, A
JSR dl.findInsertIndex

;NEED TO HANDLE DUPLICATE ENTRY

SET B, A
SET A, POP
SET PC, dl.unsortedInsert ;exit when this subroutine exits
 ;

;:### dl.searchValTable (searchTerm, tableLocation, tableLength)
;:Performs a binary search on the table at *tableLocation* (with length *tableLength*) for *searchTerm* and returns the memory location
;:
:dl.searchValTable
IFE C, 0 ;if *tableLength* is zero, return the tableLocation
  SET PC, dl.searchValTable.noLength

IFE C, 1
  SET PC, dl.searchValTable.lengthOne

SET PUSH, I

:dl.searchValTable.recheck
SET I, C
SHR I, 1 ;divide by 2
ADD I, B

IFE [I], A
SET PC, dl.searchValTable.found

IFE C, 1
  SET PC, dl.searchValTable.exf

IFG A, [I]
  SET PC, dl.searchValTable.toolow

IFL A, [I]
  SET PC, dl.searchValTable.toohigh

SET PC, dl.searchValTable.recheck

:dl.searchValTable.toohigh
SET C, I
SUB C, B
SET PC, dl.searchValTable.recheck

:dl.searchValTable.toolow
ADD C, B
SUB C, I
SET B, I
SET PC, dl.searchValTable.recheck

:dl.searchValTable.found
SET A, I
SET I, POP
SET PC, POP

:dl.searchValTable.noLength
SET A, B
SET PC, POP

:dl.searchValTable.lengthOne
IFG A, [B] ;if *insertValue* is greater than the existing value
  ADD B, 1 ;look at the second value

SET A, B ;return B
SET PC, POP

:dl.searchValTable.exf
SET A, 1
SET I, POP
SET PC, POP
 ;

;:### dl.findInsertIndex (searchTerm, tableLocation, tableLength)
;:Returns the index at which *searchTerm* should be inserted to keep the table at *tableLocation* with length *tableLength* sorted.
;:
:dl.findInsertIndex
JSR dl.searchValTable

IFE A, 1 ;if the value isn't there
  ADD A, B ;add B to make it the index to insert at

;DO SOMETHING IF A != 1 AND LENGTH ISN'T LOW
  
SET PC, POP
 ;
 
;:### dl.unsortedInsert (insertValue, insertLocation)
;:Inserts *insertValue* at *insertLocation* and pushes the value it would replace upward in memory recursively until only a null is overwritten.
;:**returns** *insertLocation*
;:
:dl.unsortedInsert
SET PUSH, I
SET PUSH, X ;SHOULD JUST USE A
SET PUSH, Y ;SHOULD JUST USE B

SET PUSH, B
SET I, B
SET X, A

:dl.unsortedInsert.loop
IFE X, 0
  SET PC, dl.unsortedInsert.exit
SET Y, [I]
STI [I], X
SET X, Y

SET PC, dl.unsortedInsert.loop

:dl.unsortedInsert.exit
SET A, POP
SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;
 ;;
 

:screendata
:ht dat 0,0,0,0

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CRYPT ; Cryptography Lib ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;:# Crypt
;:Cryptography Library
;:

;:### crp.sum (inputPointer, inputLength)
;:Performs a BSD-checksum operation.
;:**returns** the 16-bit hash
;:
:crp.sum
ADD B, A
SET C, 0

:crp.sum.loop
SHR C, 1
BOR C, EX ;checksum = (checksum >> 1) + ((checksum & 1) << 15)

ADD C, [A] ;checksum += ch

ADD A, 1

IFN A, B
  SET PC, crp.sum.loop

SET A, C
SET PC, POP

;:### <strike>crp.dsHash (inputPointer, inputLength)</strike>
;:***depricated***
;:Reads data of *inputLength* from *inputPointer* and performs a hash function on it.
;:**returns** the 16-bit hash
;:
;:For every value, shift the word *i* left and BOR with EX. XOR all of the resulting values together to produce the hash.
;:```python
;:for i in inputLength:
;:	output ^ (inputPointer[i] << i)
;:```
;:

:crp.dsHash
SET PUSH, I
SET PUSH, J
SET I, A
SET J, 0

SET A, 0
ADD B, I ;B becomes the exit location

:crp.dsHash.loop
SET C, [I]
SHL C, J
BOR C, EX
XOR A, C

STI C, 0 ;efficient I and J increment
IFL I, B
  SET PC, crp.dsHash.loop

SET J, POP
SET I, POP
SET PC, POP
 ;

; ; ; ;
;;;;;;;;;;;;;;;;
; DASH ; Shell ;
;;;;;;;;;;;;;;;;
;:The DASH Shell is essential to cubeOS's function. It acts as an interpreter for ASCII commands, <strike>which are passed to the package manager in order to directly execute subroutines,</strike> and also handles keyboard input.
;:
;:## Usage
;:At the prompt, the user can use an attached Generic Keyboard to input ASCII and control characters. 
;:
;:## Control Characters
;:
;:### Control + Delete
;:Restarts the DASH Shell by calling *s.instance*.
;:
;:## Subroutines

:v.sPrompt DAT 0xF001, "$ ", 0
:v.promptLoc DAT 0

:v.stdin DAT s.stdin.space
:v.stdout DAT s.stdout.space

;:### s.instance
;:Prepares a new terminal session at the root directory.
;:
;:1. SHOULD Set *v.cwds* to "/ " in packed form (`0x202F`)
;:2. Clears the screen
;:3. Calls *s.takeIn*
;:4. Calls *s.parse*
;:5. Calls *s.stdout* with the argument being the cursor location when the user pressed enter
;:6. Loops nonendingly to 3
;:
:s.instance
JSR sv.clear ;clear the screen
SET A, [v.scrnLoc]

:s.instance.promptLoop
JSR s.takeIn
SET PUSH, A ;keep track of cursor location

JSR s.parse

SET A, POP ;restore cursor location for passing to s.stdout
JSR s.stdout

SET PC, s.instance.promptLoop

SET PC, POP
 ;
 
;:### s.takeIn (cursorPointer)
;:Writes a prompt to the screen using *v.sPrompt* and enters a loop to take ASCII input from the keyboard and write it to the screen at *cursorPointer*. It exits when the user presses `enter`.
;:
;:**returns** the cursor location on exit
;:
:s.takeIn
SET PUSH, I
SET I, 0

JSR sv.getNewLine ;get the next blank line after *cursorPointer*
JSR s.drawPrompt ;draw the prompt using s.drawPrompt

SET A, 1 ;HWI parameter

:s.takeIn.loop
IFL I, [v.promptLoc]
  SET I, [v.promptLoc]
SET [I], 0xf09e ;cursor character

:s.takeIn.wait
HWI [HW.GenericKeyboard]

IFG C, 0x1f
  IFL C, 0x80
    SET PC, s.takeIn.write

IFE C, 0x10
  SET PC, s.takeIn.backspace

IFE C, 0x11
  SET PC, s.takeIn.enter
  
;INSERT (0x12)
  
IFE C, 0x13
  SET PC, s.takeIn.delete
  
SET PC, s.takeIn.wait


:s.takeIn.write
XOR C, 0xF000
STI [I], C

IFN I, [v.scrnEnd] ;write normally
  SET PC, s.takeIn.loop

:s.takeIn.write.scroll
SUB [v.promptLoc], [v.scrnWidth] ;make prompt scroll, too
JSR sv.scrollUp ;scroll everything up
SET PC, s.takeIn.loop


:s.takeIn.backspace
STD [I], 0
SET [I], 0
SET PC, s.takeIn.loop
 ;

:s.takeIn.delete
SET A, 2 ;changes interrupt action, so must be reset afterward
SET B, 0x91 ;sets B to the *Control* key
HWI [HW.GenericKeyboard] ;C becomes 1 if *Control* is pressed

IFE C, 1 ;exit if 
  SET PC, s.instance

SET A, 1 ;reset interrupt action
SET PC, s.takeIn.loop
 ;

:s.takeIn.enter
SET [I], 0
SET A, [v.promptLoc]
SET B, I ;UNNECESSARY ASSIGNMENT OF CURSOR POSITION
JSR s.stdin

SET A, I;return location in A
SET I, POP
SET PC, POP
 ;

;:### s.parse
;:This subroutine isolates the first argument in *v.stdin* by scanning through, then stopping on null or 0x20. Then, it gets the *crp.dshash* of the string. Then, it calls *p.lookup*, sets `B` to the location of stdin and `C` to the location of stdout, and invokes the subroutine returned by *p.lookup*.
;:
;:This should also point the process to the starts of the remaining arguments.
;:
:s.parse
SET A, [v.stdout] ;prepare stdout by nullifying the first word
SET [A], 0x0000   ;to overwrite old output if it exists

SET A, [v.stdin] ;make both A and B the location of stdin
SET B, A         ;for length-finding later

:s.parse.getFirstArg
IFC [B], 0x20 ;if [B] is 0x0000 or 0x0020
  SET PC, s.parse.exit
ADD B, 1
SET PC, s.parse.getFirstArg

:s.parse.exit
SUB B, A ;make B the length of the first argument
JSR crp.dsHash ;returns the hashvalue in A

JSR p.lookup

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
IAG B
SET PUSH, B ;push IA

SET B, s.args
SET C, [v.stdout]

JSR A ;calls the subroutine returned by *p.lookup*

IAS POP
SET Z, POP
SET Y, POP
SET X, POP
SET J, POP
SET I, POP

SET A, 0
SET B, [v.scrnLoc]
HWI [HW.LEM1802]

SET PC, POP
 ;

;:### s.drawPrompt (pointer)
;:Draws a prompt using *env.cwds* and *v.sPrompt* at *pointer* and sets *v.promptLoc* to the location following the prompt.
;:
;:**returns** the location following the prompt
;:
:s.drawPrompt

SET B, A
SET A, v.sPrompt
JSR sv.write

SET [v.promptLoc], A

SET PC, POP
 ;

;:### s.stdin (startPointer)
;:Performs a C-style copy from *startPointer* to *v.stdin*, replacing un-(single)quoted spaces with zeros.
;:
:s.stdin
SET PUSH, I
SET PUSH, J
SET PUSH, X
SET I, A
SET X, 1 ;the argument indexing index ($1, $2)
SET B, [v.stdin]

SET [s.args], B ;handle $0 separately

:s.stdin.loop
STI [B], [I]
AND [B], 0x007F

IFE [B], 0x27 ;single quote
  XOR [s.stdin.quoteflag], 1 ;flip state
  
IFN [s.stdin.quoteflag], 1 ;unless they're quoted
  IFE [B], 0x20 ;set spaces
    JSR s.stdin.newarg

ADD B, 1

IFN [I], 0
  SET PC, s.stdin.loop

SET [B], 0
IFL X, 15
  SET [s.args + J], 0 ;zero the pointer following the last argument
SET X, POP
SET J, POP
SET I, POP
SET PC, POP

:s.stdin.newarg
SET [B], 0
SET C, B
ADD C, 1
IFL X, 15
  SET [s.args + X], C
ADD X, 1
SET PC, POP


:s.stdin.quoteflag DAT 0 ;is 1 if iterator is inside quotes
;:s.stdin.escflag DAT 0 ;is 1 if "\" was the most recent character

;:s.stdin.args ;for handling arguments
;DAT 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
 ;

;:### s.stdout (outputPointer)
;:Does a C-style copy from *v.stdout* to *outputPointer*.
:s.stdout
JSR sv.getNewLine

SET B, A ;output
SET A, [v.stdout] ;input
SET PC, sv.write ;process to screen (null-terminated)
 ;
;;RESERVED SPACE

;for keeping track of where arguments are
:s.args
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

:s.stdin.space
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
:s.stdout.space
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

;current working directory in ascii
:v.cwds
DAT 0x202f, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 ;;

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HEAPMAN ; Heap Manager   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# Heap Manager
;:

;:### heap.init
;:(location, length, blocksize)
;:heap.init reserves a 4 word header followed by a bit map of all blocks. The size of the bit map is (*maxlength*/*blocksize*)/16. *length* is actually the length of the heap, excluding the header and bit map.
;:
;:The header consists of a magic word, **0x9ea9**, the location of the first block in memory, the size of each block, and the maximum length of the heap.
;:
;:**This subroutine clears all of the space given to it.**
;:
;:**returns** location of header
;:

:heap.init
SET PUSH, I
SET PUSH, J
SET PUSH, X

SET [env.heap], A

SET I, A
SET PUSH, A
SET A, B

DIV A, C
SET X, A ;store the number of blocks
DIV A, 16 ;OPTIMIZE WITH SHR

ADD A, PEEK
ADD A, 4 ;make A the location of the start of the first block

STI [I], 0x9EA9	;0
STI [I], A
STI [I], C
STI [I], B

SET PUSH, B
SET PUSH, A

:heap.init.map
SET A, 0xFFFF
SHR A, X
STI [I], A

IFL X, 16
  SET PC, heap.init.map.exit

SUB X, 16
IFN X, 0
  SET PC, heap.init.map

:heap.init.map.exit

SET A, POP
SET I, A
ADD I, POP ;create ending location

:heap.init.loop ;clear backwards
IFE I, A
  SET PC, heap.init.exit
STD [I], 0
SET PC, heap.init.loop

:heap.init.exit
SET A, POP
SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### heap.alloc (length)
;:Reserves the first consecutive *length* of memory in the heap.
;:
;:**returns** the location of the reserved memory, <strike>or 1 if no such block of memory is available</strike>
;:**UNDER DEVELOPMENT; DO NOT USE**
;:
:heap.alloc
SET PUSH, I
SET PUSH, J

SET B, [env.heap+2] ;make B the length of the blocks
DIV A, B ;make A the number of blocks needed
SET I, A

SET B, env.heap+4 ;make B the location of the map

SET J, 0
:heap.alloc.checkbits
SET C, [B]
SHR C, J

ADD J, 1
IFN J, 16
  SET PC, heap.alloc.checkbits.checks

ADD B, 1 ;SHOULD CHECK FOR THE END OF THE USAGEMAP
SET J, 0

:heap.alloc.checkbits.checks

IFC C, 0x8000	;if the leftmost bit is 0,
  SUB I, 1		;subtract one from the number of blocks remaining

IFB C, 0x8000	;if the leftmost bit in 1,
  SET I, A		;reset the counter

IFN I, 0		;continue scanning
  SET PC, heap.alloc.checkbits

;NEED TO FIND THE LOCATION OF THE FIRST BLOCK
;NEED TO RESERVE THOSE BLOCKS
 ;;

; ; ; ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PACKAGE ; Dash Package Handler ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.tableLen DAT 0 ;number of commands in the tables

;:### p.init
;:Initializes all of the pre-defined packages and their respective commands so that they can be accessed in a table.
;:
:p.init
SET A, p.hashTable
SET B, 128
SET C, 0
JSR dl.makeHashTable

;">loadcalls" is replaced by the calls necessary to load included packages

SET A, package.ls
JSR p.loadPackage

SET A, package.test
JSR p.loadPackage

SET A, package.tune
JSR p.loadPackage

SET A, package.rainbow
JSR p.loadPackage

SET A, package.val
JSR p.loadPackage

SET A, package.pwd
JSR p.loadPackage

SET A, package.inferno
JSR p.loadPackage

SET A, package.benchmark
JSR p.loadPackage

SET A, package.echo
JSR p.loadPackage

SET A, package.story
JSR p.loadPackage

SET A, package.sum
JSR p.loadPackage

SET A, package.etype
JSR p.loadPackage


SET PC, POP
 ;
 
;:### p.loadPackage (pointer)
;:Loads a package by adding the *identifier*'s crp.dsHash value and a pointer to the first instruction to the hash table. See Packages for more details.
;:
;:**returns** <strike>0 if successful,</strike> 1 if invalid package format
;:
:p.loadPackage
IFE [A], 0xffab
  IFE [A+1], 0xcdff
    SET PC, p.loadPackage.continue

SET PC, exf ;fail if not invalid header

:p.loadPackage.continue
ADD A, 2

SET B, A

:p.loadPackage.findNullinIdentifier
ADD B, 1
IFN [B], 0
  SET PC, p.loadPackage.findNullinIdentifier

SET PUSH, B ;store the location of the null before instructions
SUB B, A ;make B the length of the identifier
;A is the start of the identifier

JSR crp.dsHash

;A is now the dsHash of the identifier
SET B, POP ;B is a pointer the null
ADD B, 1 ;B is now a pointer to the first instruction
SET C, p.hashTable ;C is a pointer to the hash table
SET PC, dl.hashInsert ;add the package to the table and exit with subroutine
 ;
 
;:### p.lookup (key)
;:Looks up a package in *p.hashTable* with *key*.
;:**returns** a pointer to the main subroutine of the package
;:
:p.lookup
SET B, p.hashTable
JSR dl.hashGet ;returns value in A

IFE A, 1 ;If the value is not found,
  SET A, p.nocmd ;print "invalid command" statement

SET PC, POP
 ;

:p.hashTable
DAT 0, 0, 0, 0

:p.hashTableLookup ;(128)
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

:p.hashTableValue ;(128)
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

:p.nocmd
SET A, p.nocmd.text
SET B, [v.stdout]
SET PC, typ.cCopy

:p.nocmd.text
DAT 0x7001, "Invalid command.", 0 ;THIS SHOULD BE PACKED TEXT

;:## Packages
;:Packages are loaded by the DASH Package Handler at boot time. Standard packages are included in the module, and other packages can be loaded by calling p.loadPackage with a pointer to the header of the package.
;:Packages are identified by the magic number `0xffab cdff`, and contain a null-terminated string, the *identifier*. The index after the null in that string is the first instruction of the package.
;:Packages are invoked in the DASH Shell by typing the *identifier*, letter for letter. Packages have by definition one modifier, and can hence have only one entry point. (A package cannot define two new top-level commands.) A package can, however, do its own parsing once it is invoked by reading `stdin`. This allows for such combinations as are seen in `git init`, `git pull`, `git push`, et cetera.
;:

;">packages" is replaced by the contents of package files.
;:### package.ls
;:Writes the names all of the links (files and directories) in the current working directory to stdout.
;:
;:**author** SashaCrofter
;:

:package.ls

DAT 0xffab, 0xcdff
DAT "ls",0
SET PUSH, I

SET [C], 0xf001
ADD C, 1

SET PUSH, C

SET I, 0xA000 ;NEEDS ALLOCATED HEAP SPACE BEFORE MOVING TO A PROCESS MODEL

;SET A, [B+1]
;- get sector from relative or absolute filepath ;only modifies A

SET A, 0
SET B, I ;continuous memory location
JSR cat.open ;open root directory

SET A, I
ADD A, 6 ;set A to the first text location

SET B, POP ;set B to the output location

SET I, [I+3] ;set C to the content length
SHR I, 4 ;set C to the number of links (divide by 16)

:package.ls.loop
IFE I, 0
  SET PC, package.ls.exit ;exit if all of the links have been listed

SET PUSH, A ;store the input location
JSR typ.cCopy

SET B, A ;set B to the end of the output location
SET [B], 0x000A ;LF (\n)
ADD B, 1

SET A, POP ;set A to the input location
ADD A, 16 ;set A to the location of the next link

SUB I, 1
SET PC, package.ls.loop

:package.ls.exit
SET I, POP
SET PC, POP
 ;
:package.test
DAT 0xffab, 0xcdff
DAT "test", 0

SET PUSH, C

SET B, [B+1]
SET A, 1
JSR cat.getSector

SET B, POP
JSR typ.htoascii
SET [A], 0
SET PC, POP
:package.tune
DAT 0xffab, 0xcdff
DAT "tune", 0

SET A, [package.tune.beepsub]
JSR pih.newMsg


SET C, package.tune.lengths
SET Y, [C]
SET X, package.tune.freqs

SET B, A
SET A, 2
HWI [HW.GenericClock]

SET PC, POP

:package.tune.beepsub
IFE Y, 0
SET PUSH, PC
IFE Y, 0
SET PC, package.tune.beepsub.nextTone
IFE [C], 0
SET PC, package.tune.beepsub.end
SET B, 0
IFE [X], 0
IFE [C], 0
HWI [HW.GenericClock]
SUB Y, 1
SET PC, POP

:package.tune.beepsub.nextTone
ADD X, 1
ADD C, 1
SET Y, [C]
SET A, 0
SET B, [X]
HWI [HW.Speaker]
SET PC, POP

:package.tune.beepsub.end
SET A, 0
SET B, 0
HWI [HW.Speaker]
SET A, 2
SET B, 0
HWI [HW.GenericClock]
SET PC, POP


:package.tune.freqs
DAT 1024, 174, 220, 294, 370, 330, 392, 0, 0

:package.tune.lengths
DAT 4, 4, 4, 8, 4, 12, 1, 0

:package.tune.space
DAT 0, 0, 0, 0
;:### package.rainbow
;:Prints gawdgasm in glorious rainbowy letters
;:
;:**author** dylwhich
;:

:package.rainbow
DAT 0xffab, 0xcdff
DAT "rainbow", 0

;sets the color
SET A, package.gawd.text
SET B, C ;make B point to stdout
SET PC, typ.cCopy

:package.gawd.text
DAT 0xc001, "R", 0xe001, "A", 0xa001, "I", 0x2001, "N", 0xb001, "B", 0x9001, "O", 0xd001, "W", 0
;:### package.val
;:Returns the hex value for a given ASCII character
;:
;:**author** dylwhich
;:

:package.val
DAT 0xffab, 0xcdff
DAT "val", 0

SET A, [B+1]
SET A, [A]
SET B, C
SET [B], 0xf001
ADD B, 1
JSR typ.htoascii

SET [B], 0
SET PC, POP
;:### package.pwd
;:Prints the current working directory.
;:
;:**author** dylwhich
;:

:package.pwd
DAT 0xffab, 0xcdff
DAT "pwd", 0

;sets the color
SET [C], 0xf001
ADD C, 1

SET A, v.cwds
SET B, C
SET PC, typ.cUnpack
:package.inferno

DAT 0xffab, 0xcdff
DAT "inferno",0


SET A, pack.inferno.text
SET B, C
SET PC, typ.cCopy

:pack.inferno.text DAT 0xF001, "Lasciate ogne speranza, voi ch'intrate.", 0
 ;
:package.benchmark
DAT 0xffab, 0xcdff
DAT "benchmark", 0

SET PUSH, I
SET PUSH, J
SET I, 10

SET A, package.benchmark.checkforexit
JSR pih.newMsg

SET B, A
SET A, 1
HWI [HW.GenericClock]

:package.benchmark.cycle
SET B, 167 ;1000 / 6
:package.benchmark.cycle.loop
SUB B, 1
IFN B, 0
  SET PC, package.benchmark.cycle.loop

ADD A, 1 ;add 1000 cycles 
SET PC, package.benchmark.cycle ;only exit if 

:package.benchmark.checkforexit
SUB I, 1
IFN I, 0
  RFI 0

SET I, A

SET A, 1
SET B, 0
HWI [HW.GenericClock]

SET A, I

SET I, C
STI [I], 0xf001

SET B, I
JSR typ.htoascii

SET I, B
STI [I], 0x20
STI [I], 0x6b ;"k"
STI [I], 0x48 ;"H"
STI [I], 0x7a ;"z"

SET J, POP
SET I, POP
SET PC, POP

:package.echo
DAT 0xffab, 0xcdff
DAT "echo", 0

SET A, [B+1]
SET B, C
SET [B], 0xf001
ADD B, 1
SET PC, typ.cCopy
:package.story
DAT 0xffab, 0xcdff
DAT "story", 0

SET A, package.story.text
SET B, C
SET PC, typ.cCopy

:package.story.text
DAT 0x5468, 0x6520, 0x6c61, 0x7374, 0x2071, 0x7565, 0x7374, 0x696f, 0x6e20, 0x7761, 0x7320, 0x6173, 0x6b65, 0x6420, 0x666f, 0x7220, 0x7468, 0x6520, 0x6669, 0x7273, 0x7420, 0x7469, 0x6d65, 0x2c20, 0x6861, 0x6c66, 0x2069, 0x6e20, 0x6a65, 0x7374, 0x2c20, 0x6f6e, 0x204d, 0x6179, 0x2032, 0x312c, 0x2032, 0x3036, 0x312c, 0x2061, 0x7420, 0x6120, 0x7469, 0x6d65, 0x2077, 0x6865, 0x6e20, 0x6875, 0x6d61, 0x6e69, 0x7479, 0x2066, 0x6972, 0x7374, 0x2073, 0x7465, 0x7070, 0x6564, 0x2069, 0x6e74, 0x6f20, 0x7468, 0x6520, 0x6c69, 0x6768, 0x742e, 0x2054, 0x6865, 0x2071, 0x7565, 0x7374, 0x696f, 0x6e20, 0x6361, 0x6d65, 0x2061, 0x626f, 0x7574, 0x2061, 0x7320, 0x6120, 0x7265, 0x7375, 0x6c74, 0x206f, 0x6620, 0x6120, 0x6669, 0x7665, 0x2064, 0x6f6c, 0x6c61, 0x7220, 0x6265, 0x7420, 0x6f76, 0x6572, 0x2068, 0x6967, 0x6862, 0x616c, 0x6c73, 0x2c20, 0x616e, 0x6420, 0x6974, 0x2068, 0x6170, 0x7065, 0x6e65, 0x6420, 0x7468, 0x6973, 0x2077, 0x6179, 0x3a0a, 0x0000
:package.sum
DAT 0xffab, 0xcdff
DAT "sum", 0


;:### package.etype
;:*eTYPE*
;:THE most ADVANCED text editor for the DCPU-16!
;:Made by (Not)encore

:package.etype ;Header

DAT 0xffab, 0xcdff
DAT "etype",0

;Proper program
set a, 0
set b, vram
set c, 0
set x, 0
set y, 0
set z, vram
set i, 0
set j, 0
hwi [HW.LEM1802] ;HWI's the screen
set b, 1
set a, 3
hwi [HW.GenericKeyboard]
set b, 0
set a, 0
set c, 0x9F ;-----V
bor c, [color] ;--V
    set x, b
    add x, z
    set [x], c ;Sets cursor + colour. ;Makes the screen look inputtable.
set y, 384

:keyget ;Gets keystate then lets the handler handle it.
set a, 1
hwi [HW.GenericKeyboard]
ifn c, 0
    set pc, keyhandle
set pc, keyget
    
:keyhandle ;decides what to do, whether the character is printable or not.
ifg c, 0x1F ;If the character is in the writable range 0x20-0x7F, we let :asciihandle handle it.
    ifl c, 0x80
        set pc, charhandle ;Not JSR'd because asciihandle does stuff with the c register
ife c, 0x10 ;If the character is a backspace, it is handled by :backspacehandle
    ifg b, 0
        jsr backspacehandle
ife c, 0x11 ;If the character is an enter, it is handled by :enterhandle
    jsr enterhandle
ifg c, 0x7F
    ifl c, 0x82
        jsr arrowhandle
ife c, 0x91 ;If the character is control, turn on the control flag.
	xor i, 0x0002
set pc, keyget

:charhandle ;Handles showable characters
ifb i, 0x2 ;Checks if the control bit is down.
	set pc, controlhandle
ifb i, 0x4 ;Checks if the page bit is down.
	set pc, pagehandle
bor c, [color]
    set x, b
    add x, z
    set [x], c
add b, 1
ife b, y
    jsr lineplus ;If B is larger then VRAM then lineplus.
set c, 0x9F ;-----V
bor c, [color] ;--V
    set x, b
    add x, z
    set [x], c ;Sets cursor + colour.
set pc, keyget

:lineplus ;Adds a page to the document.
set a, 0
set b, vram
add b, 384
hwi [HW.LEM1802]
add z, 1
set b, 0
set pc, pop

:backspacehandle ;Handles backspaces
    set x, b
    add x, z
    set [x], 0xF020
ifn z, 0
sub b, 1
set c, 0x9F ;-----V
bor c, [color] ;--V
    set x, b
    add x, z
    set [x], c ;Sets cursor + colour.
set pc, pop

:enterhandle ;Handles enter.
    set x, b
    add x, z
    set [x], 0xF020
add b, 32
div b, 32
mul b, 32
ife b, y
	ifn z, 1
		jsr lineplus ;If B is larger then VRAM then lineplus.
set c, 0x9F ;-----V
bor c, [color] ;--V
    set x, b
    add x, z
    set [x], c ;Sets cursor + colour.
set pc, pop

:arrowhandle ;Handles vertical arrow keys.
    set x, b
    add x, z
    set [x], 0xF020
ife c, 0x80
    ifg b, 31
        sub b, 32
ife c, 0x81
    ifl b, 353
        add b, 32
    set c, 0x9F ;-----V
bor c, [color] ;------V
    set x, b
    add x, z
    set [x], c ;Sets cursor + colour.
set pc, pop

:controlhandle ;Handles control key.
ifn c, 0x70
	and [color], 0x0FFF
ifn c, 0x71
	and [color], 0x0FFF
ife c, 0x6B ;Control k makes blacK
	bor i, 0x8
ife c, 0x62 ;Control b makes BLUE
	add [color], 0x1000
ife c, 0x67 ;Control g makes GREEN
	add [color], 0x2000
ife c, 0x74 ;Control t makes TEAL
	add [color], 0x3000
ife c, 0x72 ;Control r makes RED
	add [color], 0x4000
ife c, 0x76 ;Control v makes VIOLET
	add [color], 0x5000
ife c, 0x6E ;Control n makes browN or burNt orange
	add [color], 0x6000
ife c, 0x77 ;Control W makes WHITE
	add [color], 0xF000
ife c, 0x4B ;Shift+Control k makes highlighted blacK
	add [color], 0x8000
ife c, 0x42 ;Shift+Control b makes highlighted BLUE
	add [color], 0x9000
ife c, 0x47 ;Shift+Control g makes highlighted GREEN
	add [color], 0xA000
ife c, 0x54 ;Shift+Control t makes highlighted TEAL
	add [color], 0xB000
ife c, 0x52 ;Shift+Control r makes highlighted RED
	add [color], 0xC000
ife c, 0x56 ;Shift+Control v makes highlighted VIOLET
	add [color], 0xD000
ife c, 0x4E ;Shift+Control n makes highlighted browN or burNt orange
	add [color], 0xE000
ife c, 0x57 ;Shift+Control W makes lowlighted WHITE
	add [color], 0x7000
ife c, 0x70 ;Control P flips the page handle bit.
	xor i, 0x4
ife c, 0x71 ;Control q quits
	bor i, 0x8
and i, 0xFFFC
set c, 0x9F ;-----V
bor c, [color] ;--V
    set x, b
    add x, z
    set [x], c ;Changes cursor colour.
set pc, keyget

:pagehandle ;Handles page.
ife c, 0x6B ;k makes blacK
	add [color], 0x0000
ife c, 0x62 ;b makes BLUE
	add [color], 0x0100
ife c, 0x67 ;g makes GREEN
	add [color], 0x0200
ife c, 0x74 ;t makes TEAL
	add [color], 0x0300
ife c, 0x72 ;r makes RED
	add [color], 0x0400
ife c, 0x76 ;v makes VIOLET
	add [color], 0x0500
ife c, 0x6E ;n makes browN or burNt orange
	add [color], 0x0600
ife c, 0x77 ;W makes WHITE
	add [color], 0x0F00
ife c, 0x4B ;Shift+k makes highlighted blacK
	add [color], 0x0800
ife c, 0x42 ;Shift+b makes highlighted BLUE
	add [color], 0x0900
ife c, 0x47 ;Shift+g makes highlighted GREEN
	add [color], 0x0A00
ife c, 0x54 ;Shift+t makes highlighted TEAL
	add [color], 0x0B00
ife c, 0x52 ;Shift+r makes highlighted RED
	add [color], 0x0C00
ife c, 0x56 ;Shift+v makes highlighted VIOLET
	add [color], 0x0D00
ife c, 0x4E ;Shift+n makes highlighted browN or burNt orange
	add [color], 0x0E00
ife c, 0x57 ;Shift+W makes lowlighted WHITE
	add [color], 0x0700
and i, 0xFFF8
set c, 0x9F ;-----V
bor c, [color] ;--V
    set x, b
    add x, z
    set [x], c ;Changes cursor colour.
set pc, keyget

:color ;Character colour
dat 0xF000

:keyboard ;Keyboard slot
dat 0x0

:screen ;Screen slot
dat 0x0

:vram ;VRAM

;.reserve 768
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0


 ;;
