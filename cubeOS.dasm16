;MIT Open License
;
;Copyright (c) 2012 Sasha Crofter

;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;
;
SET PC, __BOOT
;;;;;;;
; ENV ;
;;;;;;;
:env.cwds DAT 0
:env.fs DAT 0
 ;;
;;;;;;;;
; BOOT ;
;;;;;;;;
;:# BOOT Loader
;:Initializes the kernel on startup
;:

:__BOOT

SET A, videoram
JSR sv.init

SET A, 0x8000
SET B, 0x810
SET C, 128

JSR cat.mountSystem ;initialize FS

SET [0xB00], 0x293A
JSR p.init
JSR s.instance

SET PC, halt

:pTitle DAT 0x7563, 0x6562, 0x534f

:halt SET PC, halt
 ;;
;:## ext
;:Exits a subroutine with A set to 0
;:To use, do `SET PC, ext` instead of `SET PC, POP` at the end of a subroutine
;:
:ext ; exit true
SET A, 0
SET PC, POP
 ;

;:## exf
;:Exits a subroutine with A set to 1
;:To use, do `SET PC, exf` instead of `SET PC, POP` at the end of a subroutine
;:
:exf ; exit false
SET A, 1
SET PC, POP
 ;
;:
;;;;;;;;;;;;;;;;
; DASH ; Shell ;
;;;;;;;;;;;;;;;;

:v.sPrompt DAT 0x2024
:v.promptLoc DAT 0

:v.stdin DAT 0xA00
:v.stdout DAT 0xB00

:v.cmdmem DAT 1 ;reserve 8 words

:s.instance ;SHOULD PREPARE SDIN and SDOUT
SET [env.cwds], 0x202F

SET A, [v.scrnLoc]

:s.instance.promptLoop
JSR s.takeIn
SET PUSH, A

JSR s.parse ;outputs length for stdout

SET B, POP
JSR s.stdout
SET PC, s.instance.promptLoop

SET PC, POP
 ;

:s.parse
SET PUSH, I
SET I, [v.stdin]
SET A, v.cmdmem
SET [A], 1
SET B, 0x1F ;last five bits

:s.parse.trans
IFE [I], 0
  SET PC, s.parse.compare

SET C, B
AND C, [I]
MUL [A], C
ADD I, 1
SET PC, s.parse.trans


:s.parse.compare
AND [A], 0xFF
ADD [A], 0x900 ;MEMORY LOCATION

SET A, [A]
SET I, POP
IFE [A], 0 ;SHOULD EXIT WITH ERROR MESSAGE
  SET PC, exf
SET PC, [A] ;look up in table
 ;

:s.takeIn ; (cursorLoc)
SET PUSH, I
SET I, 0

JSR s.drawPrompt

SET A, 1 ;HWI parameter

:s.takeIn.loop
IFL I, [v.promptLoc]
  SET I, [v.promptLoc]
SET [I], 0xF09D

:s.takeIn.wait
HWI 1 ;KEYBOARD HARDWARE DEVICE

IFG C, 0x1f
  IFL C, 0x80
    SET PC, s.takeIn.write

IFE C, 0x10
  SET PC, s.takeIn.backspace

IFE C, 0x11
  SET PC, s.takeIn.enter
SET PC, s.takeIn.wait


:s.takeIn.write
XOR C, 0xF000
STI [I], C

IFN I, [v.scrnEnd] ;write normally
  SET PC, s.takeIn.loop

:s.takeIn.write.scroll
SUB [v.promptLoc], [v.scrnWidth] ;make prompt scroll, too
JSR sv.scrollUp ;scroll everything up
SET PC, s.takeIn.loop


:s.takeIn.backspace
STD [I], 0
SET [I], 0
SET PC, s.takeIn.loop


:s.takeIn.enter
SET [I], 0
SET A, [v.promptLoc]
SET B, I
JSR s.stdin

SET A, I;return location in A
SET I, POP
SET PC, POP
 ;

:s.drawPrompt ; (loc)

JSR sv.getNewLine

SET C, A
SET A, env.cwds
SET B, 1
JSR p.uStr

SET C, A
SET A, v.sPrompt
SET B, 1
JSR p.uStr

SET [v.promptLoc], A

SET PC, POP
 ;

:s.stdin ; (startLoc, stopLoc) ;NEED TO CALL THIS SUBROUTINE
SET PUSH, I
SET I, A
SET C, [v.stdin]

:s.stdin.loop
STI [C], [I]
AND [C], 0x007F
ADD C, 1

IFN I, B
  SET PC, s.stdin.loop

SET [C], 0
SET I, POP
SET PC, POP
 ;

:s.stdout ; (stdoutlen, scrnLoc) ;NEED TO WRITE AND CALL THIS
SET PUSH, A
SET A, B
JSR sv.getNewLine

SET C, A ;output
SET B, POP ;length
SET A, [v.stdout] ;location
JSR p.uStr

SET PC, POP
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT ; CAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# CAT
;:**CAT** is the default file system for cubeOS. It is based on the [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format. CubeOS uses hashes to identify links, in addition to fourteen character strings.
;:
;:**requires**
;:
;:- crypt
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**

;:## cat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a cat filesystem with the given *sectorSize*.
;:
;:Currently unsafe if the number of sectors is greater than 16
;:**returns** location of first word in header
;:

;SHOULD KEEP TRACK OF WHERE FILESYSTEM IS SO IT CAN ADD NEW STRIPS AND DO SEARCHES

:cat.mountSystem
SET [env.fs], A

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:cat.mountSystem.initHeader
STI [I], 0xC001 ;magic number, cat v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sectors start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:cat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:cat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess sectors to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, cat.mountSystem.initSectorMap.end

SUB B, 16 ;CAN WRAP AND BE UNSAFE
SET PC, cat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:cat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:cat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:cat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, cat.mountSystem.initSectorJoin.loop

:cat.mountSystem.initSectors
SET [A+4], I

:cat.mountSystem.initializeRoot
STI [I], 1 ;inode is a directory (root directory)
STI [I], 0
STI [I], 32

STI [I], 0 ;link directs here
STI [I], 0x2E ; "."
STI [I], 0
STI [I], 0 ;4
STI [I], 0
STI [I], 0
STI [I], 0
STI [I], 0 ;8
STI [I], 0
STI [I], 0
STI [I], 0
STI [I], 0 ;12
STI [I], 0
STI [I], 0
STI [I], 0
STI [I], 0 ;16

:cat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:## cat.findStrip (index)
;:Finds the location in memory of the first word in a strip at the index given.
;:
;:**returns** first word of header inode of the strip at *index*
;:

:cat.findStrip


;:## cat.newInode (location, type, length)
;:Creates a new inode at *location*.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:
;:**returns** location after inode

:cat.newInode
SET [A], B
ADD A, 2
SET [A], C
ADD A, 2
SET PC, POP
 ;

;:## cat.newLink (stripSource, stripTarg, nameLocation)
:cat.newLink
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CRYPT ; Cryptography Lib ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;:# Crypt
;:Cryptography Library
;:

;:##c.dshash (startLocation, length)
;:Dead Simple Hash
;:
;:For every value, shift the word *i* left and BOR with EX. XOR all of the resulting values together to produce the hash.
;:

:c.dshash
SET PUSH, I
SET PUSH, J
SET I, A
SET J, 0

SET A, 0
ADD B, I ;B becomes the exit location

:c.dshash.loop
SET C, [I]
SHL C, J
BOR C, EX
XOR A, C

STI C, 0 ;efficient I and J increment
IFN I, B
  SET PC, c.dshash.loop

SET J, POP
SET I, POP
SET PC, POP
 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; D32 ; 32-Bit Utility Set ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;:# d32
;:32-bit utility set
;:

;:## ifg32 (firstawordloc, firstbwordloc)
;:- returns 0 if the first 32-bit word is greater than the second 32-bit word
;:

:ifg32
SET C, A
SET A, 0 ;return 0 if true

IFG [C], [B] ;if the first is less than the second
  SET PC, ext
IFE [C], [B]
  IFG [C+1], [B+1]
    SET PC, ext

SET A, 1
SET PC, POP
 ;
;:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DATALIB ; Data Managing Library ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;:# DataLib
;:DataLib is a library for managing arbitrary amounts of data with relative speed and efficiency.
;:
;:**requires**
;:- crypt

;:## dl.searchValTable (searchTerm, location, length)
;:
:dl.searchValTable
SET PUSH, I

SET I, C
SHR I, 1 ;divide by 2
ADD I, B

IFG [I], A

:dl.searchValTable.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HEAPMAN ; Heap Manager   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# Heap Manager
:heap.loc DAT 0
:heap.header DAT 0


;:## heap.init
;:(location, allocsize, length)
;:heap.init reserves a 16 word header consisting of the following values.
;:

:heap.init ; (location, allocsize, length)
SET PUSH, I
SET PUSH, A
SET I, A
ADD A, 16 ;16 word header

STI [I], 0x9EA9	;0
;:1. **0x9EA9** magic word
STI [I], A	;1
;:1. first heap memory location
STI [I], B	;2
;:1. allocation size
STI [I], C	;3
;:1. length
STI [I], 0	;4
;:1. *reserved*
STI [I], 0	;5
;:1. *reserved*
STI [I], 0	;6
;:1. *reserved*
STI [I], 0	;7
;:1. *reserved*
STI [I], 0	;8
;:1. *reserved*
STI [I], 0	;9
;:1. *reserved*
STI [I], 0	;A
;:1. *reserved*
STI [I], 0	;B
;:1. *reserved*
STI [I], 0	;C
;:1. *reserved*
STI [I], 0	;D
;:1. *reserved*
STI [I], 0	;E
;:1. *reserved*
STI [I], 0	;F
;:1. *reserved*


ADD C, A ;create ending location
SET A, I ;have another iterator

:heap.init.loop
ADD A, B
SET [I], A

ADD I, B
IFL I, C
  SET PC, heap.init.loop

;:**STILL IN DEVELOPMENT; DO NOT USE**
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PACKAGE ; Dash Package Handler ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:p.init
SET [0x09E4], pack.ls
SET PC, POP
 ;

:pack.ls

;0b00 is stdout

SET PUSH, I
SET PUSH, J

;SHOULD LIST CURRENT DIRECTORY
;SHOULD LIST MORE THAN ONE ITEM

SET I, [env.fs]
SET I, [I+4]
SET J, [I+3] ;track length of sector
ADD I, 5 ;first letter of first link

SET A, I
SET B, 15
SET C, 0xB00

SET J, POP
SET I, POP
SET PC, POP
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
; SIMVID ; Video Manager ;
;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.scrnLoc DAT 0
:v.scrnEnd DAT 0
:v.scrnHeight DAT 12
:v.scrnWidth DAT 32

:sv.init ; (location)
SET B, A
SET A, 0
HWI 0
SET [v.scrnLoc], B
ADD B, 0x180
SET [v.scrnLoc], B
SET PC, POP

:sv.getLoc ; (xOffset, yOffset)
IFL A, [v.scrnWidth]
  IFL B, [v.scrnHeight]
    SET PC, sv.getLoc.loc ;if onscreen, continue
SET PC, exf

:sv.getLoc.loc
MUL B, [v.scrnWidth] ;make yOffset a line index
ADD A, B              ;combine them
ADD A, [v.scrnLoc]    ;make the index an index onscreen
SET PC, POP           ;return in A
 ;

:sv.autoScroll ; () does not modify registers
SET PUSH, X

SET X, [v.scrnEnd]
SUB X, [v.scrnWidth]

IFE [X], 0
  SET PC, sv.autoScroll.ex

SET PUSH, I
SET PUSH, J
SET I, [v.scrnLoc]
SET J, I
ADD J, [v.scrnWidth]

:sv.autoScroll.loop
STI [I], [J]
IFN J, X
  SET PC, sv.autoScroll.loop

SET X, J
:sv.autoScroll.looplast
STI [I], [X]
SET [X], 0
ADD X, 1
IFG X, [v.scrnEnd]
  SET PC, sv.autoScroll.subex
SET PC, sv.autoScroll.looplast

:sv.autoScroll.subex
SET J, POP
SET I, POP

:sv.autoScroll.ex
SET X, POP
SET PC, POP
 ;

:sv.scrollUp
SET PUSH, I
SET PUSH, J

SET I, [v.scrnLoc]
SET J, I
ADD J, [v.scrnWidth]

:sv.scrollUp.loop
STI [I], [J]
IFL J, [v.scrnEnd]
  SET PC, sv.scrollUp.loop

:sv.scrollUp.clearLast
SET I, [v.scrnEnd]
SUB I, [v.scrnWidth]

:sv.scrollUp.clearLast.loop
STI [I], 0
IFL I, [v.scrnEnd]
  SET PC, sv.scrollUp.clearLast.loop

SET J, POP
SET I, POP
SUB I, [v.scrnWidth] ;adjust I for caller, hopefully
SET PC, POP
 ;

;;## cstring.make (sourcePointer, targetPointer, maxLength)
;;returns B in A

:cstring.make
SET PUSH, I
SET PUSH, X
SET PUSH, Y
SET PUSH, B
SET I, A
ADD C, I

:cstring.make.packloop
STI X, [I]
AND X, 0x7F
SET [B], X ;

IFE X, 0 ;just copied a 0, so the null termination is there already
  SET PC, cstring.make.exit

IFE I, C ;have to terminate with null
  SET PC, cstring.make.exlen


STI Y, [I]
AND Y, 0x7F
SHL Y, 8

XOR [B], Y

IFE Y, 0
  SET PC, cstring.make.exit

IFN I, C ;add null termination if reached length end
  SET PC, cstring.make.packloop

:cstring.make.exlen
SET [I], 0

:cstring.make.exit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PACKER ; Data Compressor ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:p.uCol ; (packedCol, packedLen, outputChar)
SET PUSH, I
SET PUSH, X
SET PUSH, Y
SET I, C
ADD B, A
SET Y, 0

:p.uCol.selNibble

SET X, 0xF000
SHR X, Y
ADD Y, 4
AND X, [A]

:p.uCol.shift
IFB X, 0x0F00
  SET PC, p.uCol.makeWord
SHL X, 4
XOR X, EX
SET PC, p.uCol.shift

:p.uCol.makeWord
XOR X, 0x20
STI [I], X

IFL Y, 16 ;if should continue with this word
  SET PC, p.uCol.selNibble
;else, go to next word or exit
SET Y, 0
ADD A, 1

IFN A, B ;
  SET PC, p.uCol.selNibble

SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;

:p.pStr ; (fullStringLoc, fullStringLen, packedOut)
SET PUSH, I
SET PUSH, X
SET PUSH, Y
SET PUSH, Z

SET Z, 0x007F
SET I, A
ADD B, A


:p.pStr.loop
STI X, [I]
AND X, Z
SET [C], X
STI X, [I]
AND X, Z
SHL X, 8
XOR [C], x

ADD C, 1
IFL I, B
  SET PC, p.pStr.loop

SET Z, POP
SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;

:p.uStr ; (packedStringLoc, packedStringLen, packedOut)
SET PUSH, I
SET PUSH, X
SET PUSH, Y
SET PUSH, Z

SET I, C
ADD B, A
SET Z, 0x007F
SET Y, 0x7F00

:p.uStr.loop
SET X, [A]
AND X, Z
XOR X, 0xF000
STI [I], X

SET X, [A]
AND X, Y
SHR X, 8
XOR X, 0xF000
STI [I], X

ADD A, 1
IFL A, B
  SET PC, p.uStr.loop

SET A, I ;return in A

SET Z, POP
SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;
; Designated Video RAM ;
;;;;;;;;;;;;;;;;;;;;;;;;

:videoRam
DAT 0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
DAT 0,0,0xF01B,0xF01F,  0xF01F,0xF01F,0xF01F,0xF01F,  0xF01F,0xF01F,0xF01F,0xF01F,  0xF01F,0xF01F,0xF01F,0xF01F,  0xF01F,0xF01F,0xF01F,0xF01F,  0xF01F,0xF01F,0xF01F,0xF01F,  0xF01F,0xF01F,0xF01F,0xF01F, 0xF01F, 0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0xF057,0xF065,0,0,  0,0,0,0, 0,0,0,0,  0,0,0,0,  0,0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0,0x401C,0x401C,0,  0,0x401C,0x401C,0,  0,0,0,0,  0,0,0,0,  0,0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0x401E,0x401B,0x401B,0x401B,  0x401B,0x401B,0x401B,0x401D,  0,0,0,0,  0,0,0,0,  0,0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0,0x401B,0x0443,0x0455,  0x0442,0x0445,0x401B,0,  0,0,0,0,  0,0,0,0,  0,0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0,0,0x401B,0x401B,  0x401B,0x401B,0,0,  0,0,0,0,  0,0,0,0,  0,0xF01B, 0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0,0,0,0x401F,  0x401F,0,0,0,  0,0,0,0,  0,0,0,0,  0,0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0xF053,0xF063,0xF069,0xF065,  0xF06E,0xF063,0xF065,0,  0,0,0,0,  0,0,0,0, 0,0xF01B,0,0
DAT 0,0,0xF01B,0,  0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0xF01B,0,0
DAT 0,0,0xF01B,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01C,0xF01C,0xF01C,  0xF01C,0xF01B,0,0
DAT 0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0
