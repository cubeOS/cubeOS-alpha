;;;;;;;;
; BOOT ;
;;;;;;;;

SET A, bootname
SET B, 15
SET C, 4
SET PUSH, 0xF000
JSR f_dispmin

SET A, bootbar
SET B, 12
SET C, 6
SET PUSH, 0xF000
JSR f_dispmin

SET A, 0x0A00
SET B, 0x0200
SET C, 0x0100
JSR raminit

;SET A, screenid
;JSR hwscan

;SET B, 0x8000
;JSR hwmount_screen
SET [SCRN], 0x8000

JSR dashinit

SET PC, HANG

:load
SET A, 0x80CC
SET C, 0xB000
:load_l1
SET B, 1
JSR f_xor
ADD A, 1
IFG A, 0x80D5
  SET A, 0x80CC
JSR wait
SET PC, load_l1

:wait
SET PUSH, J
SET J, 10000
:wait_l1
SUB J, 1
IFG J, 0
SET PC, wait_l1

SET J, POP
SET PC, POP
 ;

:hang SET PC, hang

:bootname DAT 0x6b38, 0x3800 ;k88
:bootbar DAT 0x2a20, 0x2a20, 0x2a20, 0x2a20, 0x2a00 ;"* * * * *"

:screenid DAT 0xF615, 0x7349, 0x1802
 ;;
;;;;;;;
; ENV ;
;;;;;;;
:CWDT DAT "/", 0 ;0x2F00, 0 ;Current Working Directory in pascii form
:RAM DAT 0x0A00 ;Random Access Memory

:SCRN DAT 0 ;Active Screen

:DASHCOL DAT 0xF000 ;DASH display color
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DASH ; Shell                 ;
;                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:dashinit
SET A, [SCRN]
SET B, 0x180
JSR f_clear ;blank screen

SET A, CWDT
SET B, 1
SET C, 9
SET PUSH, [DASHCOL]
JSR f_display

SET A, s_dashprompt
SET B, 0
SET C, 10
SET PUSH, [DASHCOL]
JSR f_display

SET PC, POP
:s_dashprompt DAT "$  ", 0 ;0x2420, 0x2000 ;"$  "
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; RAMMAN ; RAM manager         ;
;                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ;[RAM] is a pointer to the first open spot of RAM
 ;Call ramcleanup when finished using RAM

;- - RAM INFO
;0 first open spot
;1 buffer beyond which RAM will reset on cleanup
;2 RAM storage length including buffer
;3 first word of RAM storage

:raminit ; (loc, len, safelen)
SET [RAM], A

SET PUSH, A
SET PUSH, B
SET PUSH, C

ADD A, 0x10 ;exclude the control words
SUB B, 0x10

SET C, [ramresword]
JSR f_replace

SET C, POP
SET B, POP
SET A, POP

ADD C, A
SET [A+1], C

SUB B, 0x10
ADD B, A
SET [A+2], B

SET B, A
ADD B, 0x10
SET [A], B ;pointer to first open spot
SET [A+3], B ;pointer to first word of ram (won't change)

SET PC, POP
:ramresword DAT 0x4E4F
 ;

:ramcleanup
SET PUSH, X
SET X, [RAM]

SET A, [X+3]
SET B, [X+2]
SET C, [ramresword]
JSR f_search

IFE A, 1
  SET PC, ramoverflow

IFL A, [X+1]
  SET PC, ramcleanup_e1

:ramcleanup_e1
SET [X], A
SET PC, POP

:ramcleanup_e2
SET [X], [X+3]
SET A, [X]
SET B, [X+2]
SET C, [ramresword]
SET PC, f_replace
 ;
:ramoverflow
SET PC, hang
 ; 
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HARDMAN ; Hardware device    ;
; manager                      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:hwscan ; (idloc)
SET PUSH, I
SET PUSH, J
SET PUSH, Z
SET J, 0
SET Z, A

HWN I

:hwscan_l1
HWQ J

IFE A, [Z]
  IFE B, [Z+1]
    IFE C, [Z+2]
      SET PC, hwscan_e1

ADD J, 1
IFN I, J
  SET PC, hwscan_l1

SET J, 0xFFFF
:hwscan_e1
SET A, J ;return

SET Z, POP
SET J, POP
SET I, POP

SET PC, POP
 ;

:hwmount_screen ; (devadr, location)
SET C, A
SET B, 0 ;do map
HWI C

SET [SCRN], A
SET PC, POP
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DERPVID ; Video Driver       ;
;                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:f_display ; (text_location, X_offset, Y_offset, XOR_effect)
SET J, SP

;X_offset is already correct form
MUL C, 32 ;to make Y_offset the correct index
ADD B, C ;to make B index
ADD B, 0x8000 ;put the index onscreen

SET C, [J+1]
JSR f_copy

SET PC, POP
 ;

:f_dispmin ; (text_location, X_offset, Y_offset, XOR_effect)
SET PUSH, B
SET B, 0xA00
JSR f_unpack

SET A, 0xA00
SET B, POP
SET PC, f_display
 ;
 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DATAMAN ; Textual and Mathe-   ;
; matical Manager                ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:f_replace ; (loc, len, fill)
SET PUSH, I
SET I, A
ADD B, A

:f_replace_l1

STI [I], C
IFN I, B
  SET PC, f_replace_l1

SET I, POP
SET PC, POP
 ;

:f_clear
SET C, 0
SET PC, f_replace
 ;

:f_search ; (loc, len, word) ;ret wordloc
ADD B, A

:f_search_l1
IFE [A], C
  SET PC, POP ;return successful
IFN A, B
  SET PC, f_search_l1

:f_search_e1
SET A, 1 ;exit failed
SET PC, POP
 ;


:f_copy ; (locsrc, loctarg, XOR_effect)
SET PUSH, I
SET PUSH, J

SET I, B ;targ
SET J, A ;src

:f_copy_l1 ;
SET B, I
STI [I], [J]

XOR [B], C

IFN [J], 0
  SET PC, f_copy_l1

SET J, POP
SET I, POP
SET PC, POP
 ;

:f_xor ; (locstart, len, XOR_effect)
ADD B, A ;set end address

:f_xor_l1
XOR [A], C
ADD A, 1
IFG B, A
  SET PC, f_xor_l1
SET PC, POP
 ;


:f_pack ; (locplaintext, locoutput)
SET PUSH, X
SET PUSH, Y
SET PUSH, I

SET I, A

:f_pack_l1
STI X, [I]
AND X, 0x007F
SHL X, 8

STI Y, [I]
AND Y, 0x007F

BOR X, Y      ; combine
SET [B], X    ; store
ADD B, 1

IFC X, 0x007F
  SET PC, f_pack_e2
IFB [I], 0x7F00
  SET PC, f_pack_l1

:f_pack_e1
SET [B], 0

:f_pack_e2

SET I, POP
SET Y, POP
SET X, POP
SET PC, POP
 ;


:f_unpack ; (locpackedtext, locoutput)
SET PUSH, I
SET PUSH, X
SET PUSH, Y

SET I, B

:f_unpack_l1
SET X, 0x7F00
SET Y, 0x007F

AND X, [A] ;get correct seven bits
IFE X, 0 ;exit before writing 0x0000
  SET PC, f_unpack_e1

SHR X, 8
STI [I], X

AND Y, [A] ;get correct seven bits
IFE Y, 0 ;exit before writing 0x0000
  SET PC, f_unpack_e1

STI [I], Y

ADD A, 1

SET PC, f_unpack_l1

:f_unpack_e1

SET Y, POP
SET X, POP
SET I, POP
SET PC, POP
 ;
 ;;
