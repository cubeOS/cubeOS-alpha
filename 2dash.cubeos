;;;;;;;;;;;;;;;;
; DASH ; Shell ;
;;;;;;;;;;;;;;;;

:v.sPrompt DAT 0x2024
:v.promptLoc DAT 0

:v.stdin DAT 0xA00
:v.stdout DAT 0xB00

:s.instance ;SHOULD PREPARE SDIN and SDOUT
SET [env.cwds], 0x202F

SET A, [v.scrnLoc]

:s.instance.promptLoop
JSR s.takeIn
SET PC, s.instance.promptLoop

SET PC, POP
 ;

:s.takeIn ; (cursorLoc) ;SHOULD PUSH AND POP I
SET PUSH, I
SET I, 0

JSR s.drawPrompt

SET A, 1 ;HWI parameter

:s.takeIn.loop
IFL I, [v.promptLoc]
  SET I, [v.promptLoc]
SET [I], 0xF09D

:s.takeIn.wait
HWI 1 ;KEYBOARD HARDWARE DEVICE

IFG C, 0x1f
  IFL C, 0x80
    SET PC, s.takeIn.write

IFE C, 0x10
  SET PC, s.takeIn.backspace

IFE C, 0x11
  SET PC, s.takeIn.enter
SET PC, s.takeIn.wait

:s.takeIn.write
XOR C, 0xF000
STI [I], C
SET PC, s.takeIn.loop

:s.takeIn.backspace
STD [I], 0
SET [I], 0
SET PC, s.takeIn.loop

:s.takeIn.enter
SET [I], 0
SET A, [v.promptLoc]
SET B, I
JSR s.stdin

SET A, I;return location in A
SET I, POP
SET PC, POP
 ;

:s.drawPrompt ; (loc)

JSR sv.getNewLine

SET C, A
SET A, env.cwds
SET B, 1
JSR p.uStr

SET C, A
SET A, v.sPrompt
SET B, 1
JSR p.uStr

SET [v.promptLoc], A

SET PC, POP
 ;

:s.stdin ; (startLoc, stopLoc) ;NEED TO CALL THIS SUBROUTINE
SET PUSH, I
SET I, A
SET C, [v.stdin]

:s.stdin.loop
STI [C], [I]
AND [C], 0x007F
ADD C, 1

IFN I, B
  SET PC, s.stdin.loop

SET [C], 0
SET I, POP
SET PC, POP
 ;

:s.stdout ; (enterLoc) ;NEED TO WRITE AND CALL THIS
 ;
 ;;
