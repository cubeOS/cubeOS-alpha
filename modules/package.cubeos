;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PACKAGE ; Dash Package Handler ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.tableLen DAT 0 ;number of commands in the tables

;:### p.init
;:Initializes all of the pre-defined packages and their respective commands so that they can be accessed in a table.
;:**Currently unstable.**
;:
:p.init
SET A, p.hashTable
SET B, 128
JSR dl.makeHashTable

;>
;LOAD CALLS BELOW ARE ADDED BY HAND. THEY SHOULD BE INSERTED PROGRAMMATICALLY DURING PRE-PROCESSING

;SET A, package.nocmd
;JSR p.loadPackage

SET A, package.ls
JSR p.loadPackage

SET A, package.inferno
JSR p.loadPackage

SET PC, POP
 ;
 
;:### p.loadPackage (pointer)
;:Loads a package by adding the *identifier*'s crp.dsHash value and a pointer to the first instruction to the hash table. See Packages for more details.
;:
;:**returns** <strike>0 if successful,</strike> 1 if invalid package format
;:
:p.loadPackage
IFN [A], 0xffab ;ONLY CHECKS FIRST WORD
  IFN [A+1], 0xcdff
    SET PC, exf ;fail if not invalid header

ADD A, 2

SET B, A

:p.loadPackage.findNullinIdentifier
ADD B, 1
IFN [B], 0
  SET PC, p.loadPackage.findNullinIdentifier

SET PUSH, B ;store the location of the null before instructions
SUB B, A ;make B the length of the identifier
;A is the start of the identifier

JSR crp.dsHash

;A is now the dsHash of the identifier
SET B, POP ;B is a pointer the null
ADD B, 1 ;B is now a pointer to the first instruction
SET C, p.hashTable ;C is a pointer to the hash table
SET PC, dl.hashInsert ;add the package to the table and exit with subroutine
 ;
 
;:### p.lookup (key)
;:Looks up a package in *p.hashTable* with *key*.
;:**returns** a pointer to the main subroutine of the package
;:
;REBOOTS WHEN CANNOT FIND KEY
:p.lookup
SET B, p.hashTable
JSR dl.hashGet ;returns value in A

SET X, A ;for debugging

SET PC, POP
 ;

:p.hashTable
DAT 0, 0, 0, 0

:p.hashTableLookup ;(128)
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

:p.hashTableValue ;(128)
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

;:## Packages
;:Packages are loaded by the DASH Package Handler at boot time. Standard packages are included in the module, and other packages can be loaded by calling p.loadPackage with a pointer to the header of the package.
;:Packages are identified by the magic number `0xffab cdff`, and contain a null-terminated string, the *identifier*. The index after the null in that string is the first instruction of the package.
;:Packages are invoked in the DASH Shell by typing the *identifier*, letter for letter. Packages have by definition one modifier, and can hence have only one entry point. (A package cannot define two new top-level commands.) A package can, however, do its own parsing once it is invoked by reading `stdin`. This allows for such combinations as are seen in `git init`, `git pull`, `git push`, et cetera.
;:

;<

;PACKAGES BELOW ARE INCLUDED BY HAND CURRENTLY. THEY SHOULD BE ADDED PROGRAMMATICALLY DURING PRE-PROCESSING

;:package.nocmd

DAT 0xffab, 0xcdff
DAT 0,0

SET A, package.nocmd.text
SET B, [v.stdout]
SET PC, typ.cCopy

:package.nocmd.text
DAT 0xf03a, 0xf028, 0

;:### package.ls
;:Writes the name first link in the root directory to stdout. <strike>Writes the names all of the links (files and directories) in the current working directory to stdout.</strike>

:package.ls

DAT 0xffab, 0xcdff
DAT "ls",0


;0b00 is stdout

SET PUSH, I
SET PUSH, J

;SHOULD LIST WHAT IS IN THE CURRENT DIRECTORY
;SHOULD LIST MORE THAN ONE ITEM

SET I, [env.fs]
SET I, [I+4]
SET J, I
ADD J, 4
;??? SET I, [J+1] ;track length of sector
;??? ADD I, 5 ;first letter of first link

SET A, J
SET B, [v.stdout]

JSR typ.cUnpack

SET J, POP
SET I, POP
SET PC, POP
 ;
 
:package.inferno


DAT 0xffab, 0xcdff
DAT "inferno",0


SET A, pack.inferno.text
SET B, [v.stdout]
SET PC, typ.cCopy

:pack.inferno.text DAT 0xf04c, 0xf061, 0xf073, 0xf063, 0xf069, 0xf061, 0xf074, 0xf065, 0xf020, 0xf06f, 0xf067, 0xf06e, 0xf065, 0xf020, 0xf073, 0xf070, 0xf065, 0xf072, 0xf061, 0xf06e, 0xf07a, 0xf061, 0xf02c, 0xf020, 0xf076, 0xf06f, 0xf069, 0xf020, 0xf063, 0xf068, 0xf027, 0xf069, 0xf06e, 0xf074, 0xf072, 0xf061, 0xf074, 0xf065, 0
 ;

 ;;
