;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PACKAGE ; Dash Package Handler ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.tableLen DAT 0 ;number of commands in the tables

;:### p.init
;:Initializes all of the pre-defined packages and their respective commands so that they can be accessed in a table.
;:**Currently unstable.**
;:
:p.init
SET A, p.hashTable
SET B, 128
SET C, 0
JSR dl.makeHashTable

;>
;LOAD CALLS BELOW ARE ADDED BY HAND. THEY SHOULD BE INSERTED PROGRAMMATICALLY DURING PRE-PROCESSING

;SET A, package.nocmd
;JSR p.loadPackage

SET A, package.ls
JSR p.loadPackage

SET A, package.inferno
JSR p.loadPackage

SET A, package.etype ;by NOTENCORE
JSR p.loadPackage

SET PC, POP
 ;
 
;:### p.loadPackage (pointer)
;:Loads a package by adding the *identifier*'s crp.dsHash value and a pointer to the first instruction to the hash table. See Packages for more details.
;:
;:**returns** <strike>0 if successful,</strike> 1 if invalid package format
;:
:p.loadPackage
IFN [A], 0xffab ;ONLY CHECKS FIRST WORD
  IFN [A+1], 0xcdff
    SET PC, exf ;fail if not invalid header

ADD A, 2

SET B, A

:p.loadPackage.findNullinIdentifier
ADD B, 1
IFN [B], 0
  SET PC, p.loadPackage.findNullinIdentifier

SET PUSH, B ;store the location of the null before instructions
SUB B, A ;make B the length of the identifier
;A is the start of the identifier

JSR crp.dsHash

;A is now the dsHash of the identifier
SET B, POP ;B is a pointer the null
ADD B, 1 ;B is now a pointer to the first instruction
SET C, p.hashTable ;C is a pointer to the hash table
SET PC, dl.hashInsert ;add the package to the table and exit with subroutine
 ;
 
;:### p.lookup (key)
;:Looks up a package in *p.hashTable* with *key*.
;:**returns** a pointer to the main subroutine of the package
;:
;REBOOTS WHEN CANNOT FIND KEY
:p.lookup
SET B, p.hashTable
JSR dl.hashGet ;returns value in A

SET X, A ;for debugging

SET PC, POP
 ;

:p.hashTable
DAT 0, 0, 0, 0

:p.hashTableLookup ;(128)
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

:p.hashTableValue ;(128)
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

;:## Packages
;:Packages are loaded by the DASH Package Handler at boot time. Standard packages are included in the module, and other packages can be loaded by calling p.loadPackage with a pointer to the header of the package.
;:Packages are identified by the magic number `0xffab cdff`, and contain a null-terminated string, the *identifier*. The index after the null in that string is the first instruction of the package.
;:Packages are invoked in the DASH Shell by typing the *identifier*, letter for letter. Packages have by definition one modifier, and can hence have only one entry point. (A package cannot define two new top-level commands.) A package can, however, do its own parsing once it is invoked by reading `stdin`. This allows for such combinations as are seen in `git init`, `git pull`, `git push`, et cetera.
;:

;<

;PACKAGES BELOW ARE INCLUDED BY HAND CURRENTLY. THEY SHOULD BE ADDED PROGRAMMATICALLY DURING PRE-PROCESSING

;:package.nocmd

DAT 0xffab, 0xcdff
DAT 0,0

SET A, package.nocmd.text
SET B, [v.stdout]
SET PC, typ.cCopy

:package.nocmd.text
DAT 0xf03a, 0xf028, 0

;:### package.ls
;:Writes the names all of the links (files and directories) in the current working directory to stdout. **Output is currently somewhat garbled.**
;:

:package.ls

DAT 0xffab, 0xcdff
DAT "ls",0


SET A, package.ls.message
SET B, [v.stdout]
SET PC, typ.cCopy

:package.ls.message DAT 0xF001, "There is no filesystem.", 0

;OLD FUNCTION
SET PUSH, I
SET PUSH, J

;SHOULD NOT ALWAYS LIST ROOT

SET I, [env.fs]
SET I, [I+4] ;I is the start of the first inode now
SET J, [I+2] ;J is the length of the first inode now
ADD J, I ;J is the stop location now
ADD I, 3 ;I is the start of the first link now

SET B, [v.stdout]
SET [B], 0xF001
ADD B, 1

:package.ls.loop ;DOES NOT LIST . PROPERLY
SET A, I
JSR typ.cCopy

SET B, A;SHOULD PUT TAB OR NEWLINE CHARACTER AFTER FILENAME 
ADD I, 16
IFL I, J
  SET PC, package.ls.loop

SET J, POP
SET I, POP
SET PC, POP
 ;
 
:package.inferno


DAT 0xffab, 0xcdff
DAT "inferno",0


SET A, pack.inferno.text
SET B, [v.stdout]
SET PC, typ.cCopy

:pack.inferno.text DAT 0xF001, "Lasciate ogne speranza, voi ch'intrate.", 0
 ;

 ;;
