SET A, 0x8000
SET B, 0x810
SET C, 128

JSR hat.mountSystem
SUB PC, 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HAT ; HAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# HAT
;:**HAT** is the default file system for cubeOS. It implements [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format. CubeOS uses version 1.0.
;:
;:**requires**
;:
;:- crypt
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**

;:## hat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a HAT filesystem with the given *sectorSize*.
;:
;:Currently unsafe if the number of sectors is greater than 16
;:**returns** location of first word in header
;:

:hat.mountSystem
SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:hat.mountSystem.initHeader
STI [I], 0x4001 ;magic number, HAT v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sectors start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:hat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:hat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess sectors to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, hat.mountSystem.initSectorMap.end

SUB B, 16 ;CAN WRAP AND BE UNSAFE
SET PC, hat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:hat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:hat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:hat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, hat.mountSystem.initSectorJoin.loop

:hat.mountSystem.initSectors
SET [A+4], I

:hat.mountSystem.initializeRoot
STI [I], 1 ;inode is a directory (root directory)
STI [I], 0
STI [I], 32

;NEEDS TO HAVE LINKS

:hat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;;:## hat.newStrip (location, stripStartSector, nameLocation)

;:## hat.newInode (location, type)
;:Creates a new inode at *location*.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:
;:**returns** location after inode

:hat.newInode
SET [A], B
ADD A, 4
SET PC, POP
 ;
