;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DVIEW ; Windowing System ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;: **dview** is CubeOS's windowing system.
;:

;:## Framework
;:

;:### dview.init (LEM1802port)
;:Reserves 32 words of memory on the stack for containing screen object locations, the first of which is a pointer to the currently active screen. Screens are added and removed as a "stack."
;:
;:**returns** dview memory location
;:
:dview.init
SET PUSH, A

SET A, 0x20
JSR heap.alloc

SET B, [v.tusk.memStack]
SET [B+1], A ;register this instance of dview to the currently running process

SET [A], A
ADD [A], 2 ;make the pointer its location plus two

SET [A+1], POP ;make the second word in the memory the relevant LEM1802 port

SET PC, POP
 ;

;:### dview.newScreen ()
;:Initializes a new screen mapping for the currently running process, adjusts the dview pointers to work with this new screen, and remaps the screen.
;:
;:**returns** the screen location
;:
:dview.newScreen
SET B, [v.tusk.memStack] ;get the running process's memory
SET B, [B+1] ;get the current dview instance's memory

SET A, 0x180 ;enough memory for one full 12x32 screen

SET PUSH, B
JSR heap.alloc
SET B, PEEK

SET B, [B] ;the dview memstack pointer points to the first open index
SET [B], A ;set the new value
           ;will increase the memstack pointer after the hardware call

SET B, PEEK

SET C, [B+1] ;get the LEM1802 port

SET A, 0 ;MEM_MAP_SCREEN
           ;B points to the word pointing to the new screen location
SET B, [B] ;so make B the pointer pointing to the new screen location
SET B, [B] ;literally, then make B the new screen location
HWI C ;the LEM1802 port

SET A, B ;return the screen location

SET B, POP
ADD [B], 1 ;move the stack pointer up

SET PC, POP
 ;

;:### dview.close ()
;:Closes the latest window for the currently running process, remapping to the one opened before that.
;:
:dview.close
SET B, [v.tusk.memStack] ;get the running process's memory
SET B, [B+1] ;get the current dview instance's memory

SUB [B], 1 ;move the memstack pointer down once
SET C, [B+1] ;get the LEM1802 port

SET PUSH, B ;store B while we remap the screen

SET A, 0 ;MEM_MAP_SCREEN
SET B, [B]        ;B is now the location of the pointer to the screen memory
SET B, [B+0xffff] ;B is now the location of the pointer to the screen before
                  ;the one we are unmapping
HWI C

SET B, POP ;restore B so that we can free the screen location we are dropping
SET B, [B] ;make B the literal pointer to the screen memory we are dropping
SET A, [B] ;make A the literal screen memory we are dropping
SET B, 0x180 ;make B the length of a 12x32 screen
JSR heap.free ;free the heap space

SET PC, POP
 ;

;:## Screen Handling
;:

;:### dview.getLoc (xCoord, yCoord)
;:Gets the memory location for the current screen at point (xCoord, yCoord).
;:
;:**modifies** A, B <br />
;:**returns** literal memory location of that point on the current screen
;:
:dview.getLoc
SET PUSH, C
SET C, [v.tusk.memStack] ;get the running process's memory
SET C, [C+1] ;get the current dview instance's memory

SET C, [C]        ;get the pointer to the pointer to screen memory
SET C, [C+0xffff] ;get the literal screen memory location
                  ;(duplicate intentional)

SHL B, 5 ;multiply by 32, the screen width

ADD A, C ;add C to A to make A a location on the screen without line number
SET C, POP ;release C

IFG B, 0x11f  ;if B is past the end of the screen,
  SET PC, exf ;exit false

ADD A, B
SET PC, POP
 ;
