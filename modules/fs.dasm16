;;;;;;;;;;;;;;;;;;;;
; FS ; File System ;
;;;;;;;;;;;;;;;;;;;;
;:# File system
;:
;:Implements CEFS, the Cube Extended File System. See help/Filesystem.md for full details.
;:
;:## Organization
;:
;:This file is split into several parts. First, the low-level functions to acquire a new block, to acquire a new inode, to release an inode/block. Second, mid-level functions to create new files and directories, manipulate directory entries, look up an entry in a directory, seek to a location in a file. Both of these levels are considered private to the filesystem, and calling them from elsewhere is discouraged.
;:Finally, the high-level functions are the filesystem API which is exposed by the OS.
;:
;:## Low level
;:
;:### fs.bitmapSearch(type)
;:Searches either the block bitmap (`type` = 0) or inode bitmap (`type` = 1) to find an empty one. Returns the number of that object. The disk block loaded into the MMR on return is undefined, do not rely on it!
;:
;:**Returns**: The number of the newly reserved inode/block in `A`.

:fs.bitmapSearch
SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z

; First, load the bitmap blocks one at a time and find a free inode/block using it.

SET PUSH, A ; Save the type on the stack.

SET B, A ; The type
MUL B, 4 ; Now B is either 0 or 4.
ADD B, 1 ; Now B is either 1 or 5, the block number for the first block of either bitmap.
SET Y, B
ADD Y, 4 ; And Y is either 5 or 9, one higher than the last block of either bitmap.

:fs.bitmapSearch.bitmapBlockLoop ; Loops over bitmap blocks, of which there are four for either type.
SET A, B
JSR disk.read

SET C, [disk.mmr] ; Index into the block
SET X, C
ADD X, 1024 ; The end condition

:fs.bitmapSearch.bitmapLoop
IFG 0xffff, [C]
  SET PC, fs.bitmapSearch.bitmapFound
ADD C, 1
IFG X, C
  SET PC, fs.bitmapSearch.bitmapLoop

; At this point, we've failed to find a free bitmap word in this block.
ADD B, 1
IFG Y, B
  SET PC, fs.bitmapSearch.bitmapBlockLoop

; At this point, we've failed to find a free block/inode completely, so exit.
SET A, 0
SET PC, fs.bitmapSearch.done

:fs.bitmapSearch.bitmapFound
; Here, we've found a non-full bitmap word that needs reducing to find which bit is free.
; The bitmap word is [C], B holds the block number.
; Loop from 0 to 15 in Z, shifting the set bit in Y left by 1 each time until ANDing Y and X=[C] yields 0, meaning that bit was unset.
SET Y, 1 ; The bitmask
SET Z, 0 ; The bit in question.

:fs.bitmapSearch.bitLoop
SET X, [C] ; The working value
AND X, Y
IFE X, 0
  SET PC, fs.bitmapSearch.bitFound

ADD Z, 1
SHL Y, 1
SET PC, fs.bitmapSearch.bitLoop
; No exit condition is necessary because we already know the word is != 0xffff and so has a free bit.

:fs.bitmapSearch.bitFound
; At this point, Y holds the relevant bitmask and Z the bit itself.
; Set the bit in [C], then compute the block number, storing it in X.
BOR [C], Y ; Now the bit is set.
SET A, B ; Put the block number into A
JSR disk.write ; And write that block back to the disk.

; Now to compute the block number. There are several steps to this: block * 16K + word * 16 + bit
SET Y, PEEK ; Restore A, the type.
MUL Y, 4 ; 0 or 4
ADD Y, 1 ; 1 or 5, the first block of the bitmap.
SUB B, Y ; The relative block number.
MUL B, 0x4000 ; Multiply by the number of bits per block of bitmap.

; C holds the word where it was found, as an absolute address in memory.
SUB C, [disk.mmr] ; Convert it back to a relative offset into the block.
MUL C, 16 ; Multiply by the number of blocks/inodes per word.
ADD B, C
ADD B, Z ; Finally, the answer.

; Y holds the type, B the block/inode number, which has been reserved in the bitmap and the bitmap block written back to the disk.
; The last thing to do is update the used count in the header.

SET Y, POP ; Save the type again, and remove it from the stack.
SET A, 0
JSR disk.read ; Load the header.

SET C, 2
ADD C, Y ; (Y the type now) Either 2 or 3, the offsets of the block and inode count, respectively.
ADD C, [disk.mmr]
ADD [C], 1 ; One more used block/inode.

SET A, 0
JSR disk.write ; Write the block back to the disk.

SET A, B ; B holds the block/inode number.

:fs.bitmapSearch.done
SET Z, POP
SET Y, POP
SET X, POP
SET C, POP
SET B, POP
SET PC, POP


;:### fs.newBlock()
;:Uses fs.bitmapSearch to find a new block and reads it into the MMR.
;:Returns the block number in `A`.
;:

:fs.newBlock
SET PUSH, Z

SET A, 0 ; The type of a block
JSR fs.bitmapSearch
; Now a block is reserved and A holds the number of it.
SET Z, A ; Save the block number.
JSR disk.read ; Load that block into the MMR.
SET A, Z ; Restore the block number.

SET Z, POP
SET PC, POP


;:### Commentary on inodes
;:An inode is stored in a block containing 64 inodes. Therefore its index in this table can be found with the lower 6 bits of the inode number, mask 0x003f, and the index into the inode meta table is the high 10 bits, mask 0xffc0.


;:### fs.getInode(inodeNumber)
;:Given an inode number, loads the disk block containing its table and returns the block number.
;:If the relevant inode table does not exist, reserves a new block and sets it up in the inode meta table.
;:Returns the block number for the inode table (which is loaded).
;:

:fs.getInode
SET PUSH, B
SET PUSH, C

SET B, A ; Store the inode number aside.
SET A, 9 ; The block number for the inode meta table.
JSR disk.read ; Read that block.

SET A, B
AND A, 0xffc0 ; Mask the meta index.
SHR A, 6 ; And shift it down.
ADD A, [disk.mmr] ; Index into the disk block

SET B, [A] ; B is the block number for the inode table.

IFG B, 0 ; If the inode table exists, skip ahead.
  SET PC, fs.getInode.loadTable

; If we come here, the inode table doesn't exist. Therefore, reserve a block and use it.

SET C, A ; Back up the index into the meta table.
JSR fs.newBlock

; Now the new block is loaded, and A holds its number.
SET B, A ; Back up the block number.
SET A, 9 ; The block number for the inode meta table.
JSR disk.read

SET [C], B ; Write the block number into the inode meta table.
SET A, 9
JSR disk.write ; And write the meta table back to the disk.

:fs.getInode.loadTable
SET A, B
JSR disk.read ; And now load the inode table.

SET A, B ; Return the block number.

SET C, POP
SET B, POP
SET PC, POP

;:### fs.newInode()
;:Reserves a new inode and returns its number. **Does not** read the inode table into the MMR, use `fs.getInode`. Returns the inode number.
;:

:fs.newInode
SET A, 1 ; Type 1 is for inodes.
JSR fs.bitmapSearch
; Now A contains the inode number.
SET PC, POP



;:### fs.bitmapFree(type, number)
;:Frees block (type 0) or inode (type 1) with the given number.
;:Does not check if the block/inode was already free. Calling this on an already free inode/block will make the header's counts of free blocks/inodes incorrect.
;:Does not zero inode entries or blocks!
;:
:fs.bitmapFree
SET PUSH, C

SET PUSH, A ; Set aside the type

MUL A, 4 ; Either 0 or 4
ADD A, 1 ; Either 1 or 5

SET C, B
SHR C, 13 ; C is the page number, 0-3
ADD A, C ; A holds the actual page in question.

SET PUSH, A
JSR disk.read

SET A, B
SHR A, 4
ADD A, [disk.mmr] ; A is the absolute address of the bitmap word.

AND B, 0x000f ; Just the bit number remains in B
SET C, 1
SHL C, B ; C has the bit in question set.
XOR C, 0xffff ; negate C
AND [A], C ; Unset that bit in the bitmap word.

SET A, POP ; Retrieve the block number
JSR disk.write ; And write out the block again.


SET A, 0
JSR disk.read ; Load the header.

SET B, POP ; Retrieve the type
ADD B, 2 ; B is either 2 or 3, the index into the header of the used inode/block count.
ADD B, [disk.mmr] ; Absolute address.
SUB [B], 1

SET A, 0
JSR disk.write ; Write out the header again.

SET C, POP
SET PC, POP



;:### fs.mkInodePtr(inodeNumber)
;:Given an inode number, loads the inode table and copies the inode into freshly allocated heap memory. Returns the pointer to that memory, which the caller must free.
:fs.mkInodePtr
SET PUSH, B
SET PUSH, C
SET PUSH, X

SET PUSH, A ; Save the inode number.

SET A, 16
JSR heap.alloc
SET X, A ; The inode pointer.

SET A, PEEK
JSR fs.getInode

SET A, POP
AND A, 0x003f ; Index of the inode in the table
SHL A, 4 ; Address in the table
ADD A, [disk.mmr] ; Absolute address

SET B, X ; destination
SET C, 16 ; length
JSR typ.memcopy

SET A, X
SET X, POP
SET C, POP
SET B, POP
SET PC, POP



;:## Mid-level
;:

;:### fs.readFileAt(inodePointer, offset)
;:Given a **pointer** to an inode in memory (**not** an inode number), and a pointer to a little endian 32-bit offset into the file, loads the relevant disk block into the MMR and returns the block number.
;:The offset of the requested data in the MMR can be computed by masking the low word of the offset with 0x03ff. Care must be taken not to read past the end of the MMR.
;:
;:Since the code that allocates memory is responsible for freeing it, this function as a courtesy preserves the value of the offset argument.
;:

:fs.readFileAt
SET PUSH, C

; First, a sanity check: If the offset is >= the file's length, bail.
IFG [B+1], [A+4] ; If the high word of the offset is larger, it's too big
  SET PC, fs.readFileAt.tooBig
IFG [A+4], [B+1] ; If the high word of the size is larger, it's small enough.
  SET PC, fs.readFileAt.offsetOK
; If we come here then they're equal, jump accordingly:
SET C, [A+3]
ADD C, 1
IFG C, [B] ; the file size's low word is larger, then it's good
  SET PC, fs.readFileAt.offsetOK

:fs.readFileAt.tooBig
; We either jumped or fell through to here because the offset is outside the file. Return 0. Callers are responsible for freeing the offset.
SET A, 0
SET PC, fs.readFileAt.done

:fs.readFileAt.offsetOK
; Next step is to find which block contains the offset in question.

IFE [B+1], 0 ; if the high word is 0
  IFG 0x2000, [B] ; and the low word is < 8K
    SET PC, fs.readFileAt.directBlocks ; Then it's in one of the direct blocks.

IFG [B+1], 8 ; If the high word is >8,
  SET PC, fs.readFileAt.doublyIndirectBlock ; Then it's doubly indirect

; Otherwise it's singly indirect.
;TODO: Handle the singly indirect block.

:fs.readFileAt.doublyIndirectBlock
HCF 0 ; Halt and catch file, unimplemented code.
; TODO: Handle the doubly indirect block.


:fs.readFileAt.directBlocks
; The offset is inside the first 8K words that can be accessed through the direct blocks.
; Next step is to determine which one. That's best done by shifting the offset.

SET C, [B] ; The low word of the offset.
SHR C, 10 ; Knock off the low 10 bits. C now counts in blocks, not words.

ADD C, A ; Points into the inode
ADD C, 6 ; and now at the right block.
SET A, [C] ; Fetch the block number.
JSR disk.read ; And read it.
SET A, [C]

:fs.readFileAt.done
SET C, POP
SET PC, POP



;:### fs.dirLookup(directory, filename)
;:Given a directory's inode number and a filename (pointer to an unpacked C string), returns the inode number of the entry (file or directory), or 0 if no such entry exists. 0 is the inode number of the root directory, but `/` is not a legal filename, and there's no directory in which to look it up, so there's no ambiguity.
;:

:fs.dirLookup
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I
SET PUSH, J

; Acquire enough memory to store an inode (16 words).
SET C, A ; Set aside the inode number.
SET A, 16
JSR heap.alloc
SET X, A ; Set aside the memory location too. X will hold the inode throughout the function.

SET A, C ; Put the inode number into A.
JSR fs.getInode ; And load the inode. A holds the block number but we don't care about that.
SET A, C ; The inode number
AND A, 0x3f ; Extract the index into the inode table.
ADD A, [disk.mmr] ; And turn it into an absolute address on the filesystem.

SET PUSH, B ; Save B, the filename pointer.
SET B, X ; The heap location set aside for the inode.
SET C, 16 ; The size of an inode.
JSR typ.memcopy ; Copy the inode data from the disk to the heap.
SET B, POP

; At this point, X points to the inode on the heap, and B holds the filename pointer.
; Now we begin checking the directory entries for data.
; First, sanity-check that this is actually a directory.
SET A, [B] ; The type value from the inode.
AND A, 0x0007 ; Mask out the type only.
IFE A, 0x0002 ; If it's a directory, then skip over the error handling.
  SET PC, fs.dirLookup.inodeOK

; Handle the case where it's not a directory.
SET A, X
JSR heap.free ; Free the inode copy.
SET PC, fs.dirLookup.error


:fs.dirLookup.inodeOK
; At this point we need to pack the string for comparison to the filenames.
SET A, B
JSR typ.ffz ; Find the first 0 in the string, A now holds its length.

ADD A, 1
DIV A, 2 ; (x+1)/2 rounded down yields x/2 rounded up. (8+1)/2 = 9/2 = 4.5 = 4, and (7+1)/2 = 4, so we can be sure A is long enough for the packed string.
SET Y, A ; Back up the length.
JSR heap.alloc ; A now holds the location where we'll put the packed string.

SET C, A ; Move the destination pointer to C,
SET A, B ; the source pointer to A,
SET B, Y ; and the length to B,
JSR typ.pPack

; Now we have the packed string in the allocated memory in C, the length in packed words in Y, and the address of the inode in X.
; Now we loop through each entry in the directory, using I to hold the offset into the file. Since the filesize is 32 bits, I actually holds a pointer to a two-word 32-bit number.
SET A, 2
JSR heap.alloc
SET [A], 0
SET [A+1], 0
SET I, A ; I holds a pointer to the 32-bit length.

:fs.dirLookup.entryLoop
SET A, X
SET B, I
; TODO: Optimization: Don't fetch if the offsets are in the same block.
JSR fs.readFileAt ; Takes the inode pointer (not number!) and pointer to the 32-bit offset, and returns a pointer to the place in memory where that word of the file now resides.

; A now holds the block number in memory, which is useless since we're not planning to write.
SET A, [I] ; The low word of the offset.
AND A, 0x03ff ; Mask out just the offset into the block.
ADD A, [disk.mmr] ; And now A points at the required data in memory.

; Compare the lengths
IFE Y, [A+2]
  SET PC, fs.dirLookup.nextEntry

; Lengths match, so start comparing strings.
SET B, A
ADD B, 3 ; B now points in memory at the start of the filename.
SET Z, C ; Z is the start of search query.
SET J, Y ; J the length.

:fs.dirLookup.filenameLoop
IFN [B], [Z] ; On a mismatch, jump out.
  SET PC, fs.dirLookup.nextEntry
ADD B, 1
ADD Z, 1
SUB J, 1
IFG J, 0
  SET PC, fs.dirLookup.filenameLoop

; If we reach this point, the filenames match and we have a winner. Store the inode number in A, free the two chunks of memory, and return.
; Those two chunks of memory are the search query packed string at C and the inode at X.
SET Z, [A+1] ; Set aside the inode number of the found entry.
SET A, C
JSR heap.free
SET A, X
JSR heap.free
SET A, I
JSR heap.free

SET A, Z ; A is the inode number.
SET PC, fs.dirLookup.done


:fs.dirLookup.nextEntry
; Look up the next entry in the directory. The offset into the directory is still in I.
; Increment it by the delta given here (if it's nonzero) and loop. If it's zero, not found.
IFE [A], 0 ; End of the entry list
  SET PC, fs.dirLookup.notFound

ADD [I], [A]
ADD [I+1], EX
SET PC, fs.dirLookup.entryLoop

:fs.dirLookup.error
:fs.dirLookup.notFound ; These labels currently point to the same place; error could be separated.
SET A, 0

:fs.dirLookup.done
SET J, POP
SET I, POP
SET Z, POP
SET Y, POP
SET X, POP
SET C, POP
SET PC, POP




;:### fs.addBlock(inodePointer)
;:Given an inode **pointer**, retrieves a new block, adds it to the inode, and returns the block number with the block loaded. Does not write the inode to disk, which must be done by the caller.
;:

:fs.addBlock
; * Acquire a new block.
; * Insert the block number into the inode at the appropriate spot.
; * Update the number of blocks in the inode.

SET PUSH, Z
SET PUSH, I

SET I, A ; I holds the inode pointer.
JSR fs.newBlock
SET Z, A
; Z holds the disk block number
; The block is loaded, though I don't need it. I leave it loaded for my caller, though.

SET A, [I+2] ; A holds the original block count.
ADD A, 6 ; A now points at the offset into the inode of the next available block.

IFG A, 13 ; Points at the singly or doubly indirect block, which I need to implement.
  HCF 0 ; TODO Handle indirect blocks.

ADD A, I ; A is now the real address of the block
SET [A], Z ; Write the block number.
ADD [I+2], 1 ; Add a block to the block count.

; All done. Return the block number of the new block.
SET A, Z
SET I, POP
SET Z, POP
SET PC, POP


;:### fs.addToDir(parent, inode, filename)
;:Given the inode number of a directory, the inode number of a file, and the name of the file (unpacked C string), adds the file to the directory. Returns nothing. The disk block loaded into the MMR upon return is undefined.
;:

:fs.addToDir
; * Look up the directory and check it really is one.
; * Construct the new entry, including its length.
; * Find the current last entry.
; * Set its pointer to after the end of itself, skipping onto the next block if necessary.
; * Write the new entry.
; * Update the block count and file size of the directory.

SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I
SET PUSH, J

SET I, A ; Store the inode number for the directory.
JSR fs.getInode
; A now contains the disk block number, and the inode table is loaded. Look up the inode itself.

SET A, I
AND A, 0x003f ; Mask just the index into the inode table.
SHL A, 4 ; Offset in words
ADD A, [disk.mmr] ; Absolute address.

SET X, [A]
AND X, 0x0007 ; Mask just the type.

IFN X, 2 ; Check the type is 2=directory
  ; Trying to add a file to a non-directory, so exit with an error. There's no return value, so we just fail silently.
  ; Using HCF for now for debugging purposes.
  HCF 0
  ;SET PC, fs.addToDir.done

; At this point, the directory inode shows it is indeed a directory.
; Now copy the inode into memory.

SET Y, A ; Set aside the address of the inode.
SET A, 16
JSR heap.alloc
SET J, A ; J holds the directory inode copy in memory.

; Save my arguments, and then copy the inode into memory.
SET PUSH, B
SET PUSH, C
SET B, A ; The destination.
SET A, Y ; The source
SET C, 16 ; The length
JSR typ.memcopy
SET C, POP
SET B, POP


; Next step is to construct the new filename entry.
; The maximum size of an entry is 3 + 128 = 131.
SET A, 131
JSR heap.alloc
SET X, A ; X holds the entry address.

SET [X], 0 ; Relative position of next entry. 0 to indicate this is the last entry.
SET [X+1], B ; Inode number of the file we're adding.

; Compute the length of the string:
SET A, C
JSR typ.ffz
; A now holds the length of the string in characters.
SET Y, A ; Save the character length.
SET A, C ; A holds the source string
SET B, Y ; B the character length
SET C, X
ADD C, 3 ; C the pointer to the destination.
JSR typ.pPack ; Packs the string into the destination.

ADD Y, 1
SHR Y, 1 ; (x+1)/2 divides by two, rounding up.
; Y now holds the length of the packed filename in words.
SET [X+2], Y ; And store that length in the directory entry.

; Now the constructed directory entry is ready.
; Registers: I the directory's inode number, X the new entry's address, J the directory inode address in memory.
; Next, find the last directory entry.

SET A, 2
JSR heap.alloc
SET Y, A ; Store the offset pointer in Y.

SET [Y], 0
SET [Y+1], 0

:fs.addToDir.entryLoop
SET A, J ; The inode pointer
SET B, Y ; And the offset
JSR fs.readFileAt
SET Z, A ; Z holds the block number of the directory entries.

SET A, [Y]
AND A, 0x03ff ; Offset into this block.
ADD A, [disk.mmr] ; Address in memory
IFE [A], 0
  SET PC, fs.addToDir.lastEntry

ADD [Y], [A]
ADD [Y+1], EX
SET PC, fs.addToDir.entryLoop

:fs.addToDir.lastEntry
; We found the last entry. A points at it in memory. Z holds the block number, I the directory inode number, and J the directory inode pointer, and Y the offset (32 bits)

; Move the offset forward by the length of the last entry.
SET B, [A+2] ; B is the length of the entry's name.
ADD B, 3 ; B is now the length of the entry in total.

; Check that this value is in the same block
SET C, B
ADD C, A ; C points at the memory location where the new block is to be written.
ADD C, [X+2] ; Add the length of the new entry's string
ADD C, 2 ; Add the rest of the new entry (3 words) minus 1.
; C now points at where the last word of the new entry will go.

IFG [disk.mmrTop], C
  SET PC, fs.addToDir.thisBlock
SET PC, fs.addToDir.nextBlock

:fs.addToDir.thisBlock
; If we come here, the entry will fit in this block and needs writing there.
SET C, [A+2] ; The length of the old entry's string.
ADD C, 3 ; And the length of the entry in total.
SET [A], C ; Write that offset into the old entry's offset.

ADD [Y], C ; And bump the master offset.

SET PC, fs.addToDir.copyEntry

:fs.addToDir.nextBlock
; If we come here, the entry needs to be bumped onto the next block.
; Compute the relative offset, write it, write this block, acquire a new block, write its number into the inode copy, load it, and write the entry there.

SET C, [disk.mmrTop]
SUB C, A ; The relative difference between the old last entry and the new entry.
SET [A], C ; And now it's written into this entry.

SET A, Z ; The block number
JSR disk.write ; Write out that data block.

; Call the helper function to append a new block to a file.
SET A, J ; The inode pointer.
JSR fs.addBlock
SET Z, A ; Z holds, again, the data block number.
; New block's number is in A, and it's loaded.
; Regs: Z new block number, I inode number, J inode pointer, Y offset, X new entry.
ADD [Y], 0x03ff ; Bump the offset definitely into the next 1K
ADD [Y+1], EX ; Update the high word appropriately.
AND [Y], 0xfc00 ; And then mask away the low 10 bits, so the offset is now the beginning of the new block. HACK

:fs.addToDir.copyEntry
; Expects Y to be the offset pointer, that gives where it should write. The data block should be loaded and Z holds its number. X points to the entry data computed earlier.
SET A, X ; source
SET B, [Y] ; destination
AND B, 0x03ff ; offset into this block
ADD B, [disk.mmr] ; absolute address of destination

SET C, [X+2] ; length of the filename field.
ADD C, 3 ; length of the new entry.
SET PUSH, C ; save the length for later.

JSR typ.memcopy ; copies into the data block.

SET A, Z
JSR disk.write ; write the data block to disk.

; Finally we need to update the file size in the inode. Y's offset points at the start of the new entry
SET C, POP ; Pop the length we saved earlier.
ADD [Y], C
ADD [Y+1], EX ; Update the offset properly.
; Y's offset now points after the last word of data in the file, and so is its length. Write it into the inode:
SET [J+3], [Y]
SET [J+4], [Y+1]

; Now, fetch the inode again and write it back to the disk.
SET A, I
JSR fs.getInode
SET Z, A ; Z holds the disk block

SET A, J ; source
SET C, 16 ; length

SET B, I ; destination. currently the inode number
AND B, 0x003f ; now an index into the table
SHL B, 4 ; now a word offset into the table
ADD B, [disk.mmr] ; now the real address

JSR typ.memcopy ; copy the inode data into the table.
SET A, Z ; The disk block
JSR disk.write ; Write the inode table back to the disk.


; Whole assload of memory to free:
SET A, J
JSR heap.free ; The inode copy.
SET A, X
JSR heap.free ; The directory entry buffer.
SET A, Y
JSR heap.free ; the offset

:fs.addToDir.done

SET J, POP
SET I, POP
SET Z, POP
SET Y, POP
SET X, POP
SET PC, POP




;:### fs.newFile(parent, filename)
;:Given the inode number of a directory and a pointer to an unpacked C-style string `filename`, create the file's inode and the necessary directory entry. Returns the inode number of the new file, or the inode number of the file, if it exists. The disk block loaded into the MMR after return is undefined.
;:

:fs.newFile
; * Check that no entry with that name already exists in the parent directory (failed file lookup).
; * Request a new inode.
; * Fetch the inode of the parent directory and add this entry.
; * Load the inode for this file and populate it appropriately.

SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, I
SET PUSH, J

SET X, A
SET Y, B
JSR fs.dirLookup ; Try to look up the file we were just told to create.

IFE A, 0
  SET PC, fs.newFile.doesNotExist

; If we came here, the file exists already, so we return 0.
SET A, 0
SET PC, fs.newFile.done

:fs.newFile.doesNotExist
; The file doesn't already exist, so we can start creating it.
; First, acquire a new inode.
JSR fs.newInode
SET I, A ; Hang on to that inode number.
; And then load it.
JSR fs.getInode
; A now contains the block number for the inode.
SET J, A ; Hang onto the block number as well.

; I (inode number) and J (block number) are now reserved for the remainder of the function.
; Set up the inode.

SET A, I
AND A, 0x003f ; Mask out the inode number (low 6 bits).
SHL A, 4 ; Shift left by 4, effective multiply by 16. This is now a word offset into the inode block.
ADD A, [disk.mmr] ; Now it's a real memory address for the inode.

SET [A], 1 ; Mark it as a file. If this was a new directory, newDir will update this value.
SET [A+1], 1 ; One link to this file. Hard links aren't implemented yet anyway.
SET [A+2], 0 ; No blocks currently assigned.
SET [A+3], 0 ; Size low word, 0.
SET [A+4], 0 ; Size high word, 0.
SET [A+5], 0 ; Reserved word, set to 0 so it has a consistent value when it becomes used later.

SET A, J ; The block number
JSR disk.write ; Write out the inode table.

SET A, X ; The parent directory,
SET B, I ; the inode number
SET C, Y ; and filename
JSR fs.addToDir

; Now the file is created and empty, and inserted into its directory.
; We return the inode number.
SET A, I

:fs.newFile.done
SET J, POP
SET I, POP
SET Y, POP
SET X, POP
SET C, POP
SET PC, POP


;:### fs.newDir(parent, name)
;:Creates a new directory under the given parent and with the given name (unpacked string)
;:Returns the inode number of the new directory, or 0 if one with that name already exists.
;:
:fs.newDir

SET PUSH, C
SET PUSH, I
SET PUSH, J

SET I, A ; I holds the inode number of the parent, which I'll need later for `..`
SET J, 0 ; Junk inode number, in case we short circuit to newDir.done.

JSR fs.newFile

IFE A, 0
  SET PC, fs.newFile.done

; If we're still here, we've got some work to do. We've constructed a new file whose inode number is in A. The inode type needs updating, and the . and .. entries
; A holds the inode of the new directory.
SET J, A ; Back up. J holds the inode of this new directory

; Update the inode type first so fs.addToDir won't error out.
JSR fs.getInode
; A holds the block number.
SET B, J
AND B, 0x003f ; index into the inode table
SHL B, 4 ; offset into the table
ADD B, [disk.mmr] ; address in real memory.
SET [B], 2 ; Set the type.

JSR disk.write ; A still holds the block number, so write it out.

; Now add the two special directories, . and ..
; We do this by hand, rather than calling fs.addToDir, because that would require a lot of special cases.
JSR fs.newBlock
SET PUSH, A ; Set aside the block number.

SET B, [disk.mmr]
SET [B], 4 ; Length of the . entry
SET [B+1], J ; Inode of this newly created directory.
SET [B+2], 1 ; Length of the name in words.
SET [B+3], 0x2e00 ; The ASCII for . is 2e

SET [B+4], 0 ; No next entry, so offset 0.
SET [B+5], I ; Inode of the parent
SET [B+6], 1 ; Length of the name
SET [B+7], 0x2e2e ; ..

JSR disk.write ; Write it back to the disk.

; Now write that new block into the inode.
SET A, J
JSR fs.getInode
; A holds the inode block number.

SET B, J
AND B, 0x003f ; index into the inode table
SHL B, 4 ; offset into the table
ADD B, [disk.mmr] ; address in real memory.

SET [B+2], 1 ; One block
SET [B+3], 8 ; Size in words.
SET [B+6], POP ; And the block number.

JSR disk.write ; Write the inode data to disk.

:fs.newDir.done
; Return the new directory's inode number.
SET A, J
SET J, POP
SET I, POP
SET C, POP
SET PC, POP



;:### fs.deleteFile(inodeNumber)
;:Given an inode number, deletes the file referred to by that inode. Frees the inode and all data blocks associated with the file. Does not zero out anything. Works for directories, but does not delete their contents, causing leaks if the directory was nonempty. There is no check for this.
;:
:fs.deleteFile
SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y

SET PUSH, A ; Hang on to the inode number for later.
JSR fs.getInode
; Loads the inode. A holds the block number for the inode table, though I won't need it.

SET A, 16
JSR heap.alloc
SET X, A ; Store the address of the inode copy in X.

SET A, PEEK ; Get the inode number on the stack.
AND A, 0x003f ; Retrieve the index into this table.
SHL A, 4 ; Multiply by 16, offset into the table.
ADD A, [disk.mmr] ; Absolute address in memory.

SET B, X ; destination
SET C, 16 ; length
JSR typ.memcopy

SET C, [X+2] ; C holds the number of blocks in this file.
IFE C, 0 ; If no blocks are used, skip the loop.
  SET PC, fs.deleteFile.deleteInode

; There are data blocks in the file, so deal with them.
SET Y, X
ADD Y, 6 ; A now points at the first data block in the inode.
ADD C, Y ; C now points after the last block used in this file.
; TODO: Handle indirect blocks.

:fs.deleteFile.blockLoop
SET A, 0 ; Type 0, block
SET B, [Y] ; The block number
JSR fs.bitmapFree

IFG C, Y
  SET PC, fs.deleteFile.blockLoop

; If we come down here, time to free the inode.
:fs.deleteFile.deleteInode
SET A, 1 ; Type 1, inode
SET B, POP ; Retrieve the inode number from the stack.
JSR fs.bitmapFree

SET A, 0
JSR disk.read ; Read the header.
SET A, [disk.mmr]
SUB [A+1], [X+2] ; Subtract the number of blocks used in this file from the total used count.
SET [A+2], 1 ; And 1 from the number of used inodes.

SET A, 0
JSR disk.write ; And write the header out again.

SET A, X
JSR heap.free ; Free the copy

SET Y, POP
SET X, POP
SET C, POP
SET B, POP
SET PC, POP



;:## High level
;:These commands are the ones intended to be called by external code. The low- and mid-level functions in this file are considered more or less private to the filesystem. The functions presented here are to be considered the filesystem API exposed by the OS.
;:
;:### fs.delete(dirInode, filename)
;:Takes the inode number of a directory and a filename within it, and deletes that file from the directory.
;:Trying to delete `.` or `..` is not supported and will cause Bad Things to happen.
;:Frees the file's blocks.
;:
:fs.delete
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I
SET PUSH, J

SET PUSH, B ; Set aside the filename
; First, look up that file in the directory.
SET I, A ; Save the directory inode.

SET A, I
JSR fs.mkInodePtr
SET X, A ; X points at a copy of the inode.


SET A, 2
JSR heap.alloc
SET Y, A ; Y holds the 32-bit offset.
SET [Y], 0
SET [Y+1], 0

SET A, PEEK ; The string from the stack.
JSR typ.ffz
SET B, A ; The length
SET Z, B

JSR heap.alloc
SET J, A ; The new string.
SET C, J ; The destination string.
SET A, POP ; The source string from the stack.
JSR typ.pPack ; J now points at the newly packed string.

SET C, Z ; The length of the string in characters.
ADD C, 1
SHR C, 1 ; Length in words

; At this point, X points at the inode copy, J at the packed string, I holds the directory inode number, Y holds the offset pointer, which is set to 0, and C the string length.

; I will hold the last delta

; Note that the target entry will not be the first because the is always `.`
:fs.delete.dirSearch
SET A, X ; inode pointer
SET B, Y ; offset pointer
JSR fs.readFileAt
; A holds the block number.

SET A, [Y]
AND A, 0x3ff ; index into the block
ADD A, [disk.mmr] ; Address of the entry.

; Check if the file matches.
IFN C, [A+2]
  SET PC, fs.delete.nextEntry ; Lengths don't match, not equal.

; If we fall through the here, the file names were the same length. Iterate through the letters.
SET PUSH, A
SET PUSH, C
ADD A, 3 ; Beginning of the string.
SET B, J
; C holds the length.
JSR typ.memeq

; Restore the two values from the stack, and save the response in B.
SET B, A
SET C, POP
SET A, POP

IFG B, 0 ; Match
  SET PC, fs.delete.entryMatch

; In this case, they don't match, so proceed to the next entry.
:fs.delete.nextEntry
SET I, [A] ; The previous offset.

ADD [Y], I
ADD [Y+1], EX

SET PC, fs.delete.dirSearch


:fs.delete.entryMatch
SET A, [Y]
AND A, 0x03ff
ADD A, [disk.mmr]
SET PUSH, [A+1] ; Store the inode for the file.
SET PUSH, [A] ; Store the offset from the entry to be deleted.

; Found a matching entry. Subtract I from [Y] and load that location.
SUB [Y], I
ADD [Y+1], EX ; Yes, ADD. EX is 0xffff if there's an underflow.

SET A, X ; inode pointer
SET B, Y ; offset pointer
JSR fs.readFileAt

; A holds the block number.

SET B, [Y]
AND B, 0x3ff ; Just the offset into the block.
ADD B, [disk.mmr] ; address

SET I, POP
IFE I, 0
  SET [B], 0 ; If the entry to be deleted was the last one, then the previous one becomes last.

ADD [B], I ; Add the offset of the to-be-deleted entry to that of the one before it. This offset now points over the deleted entry.
JSR disk.write ; Write out the entry.


; The directory entry has been removed. Now to remove all the blocks and the inode.
; First, free the memory used in the above.
SET A, X
JSR heap.free
SET A, J
JSR heap.free
SET A, Y
JSR heap.free

; Now the registers are all unreserved again.
SET I, POP ; I holds the inode number of the file we're deleting.

; Delete all its blocks.
SET A, I
JSR fs.mkInodePtr
SET X, A ; X holds the inode pointer.

SET Y, X
ADD Y, 6 ; Y points at the first data block.
SET Z, Y
ADD Z, [X+2] ; Add the block count.
; Y points at the current block, Z after the last one.
; TODO: Support indirect blocks.
:fs.delete.freeBlocks
IFE Z, Y
  SET PC, fs.delete.doneFreeBlocks

SET A, 0 ; Type 0, blocks.
SET B, [Y]
JSR fs.bitmapFree

ADD Y, 1
SET PC, fs.delete.freeBlocks

:fs.delete.doneFreeBlocks

; Free the inode pointer.
SET A, X
JSR heap.free


; Finally, delete the inode in question.
SET A, 1 ; Type 1, inode.
SET B, I ; Retrieve the inode number.
JSR fs.bitmapFree

SET J, POP
SET I, POP
SET Z, POP
SET Y, POP
SET X, POP
SET C, POP
SET PC, POP



;:### fs.format(size_in_KW)
;:Given a size (measured in 1K blocks), formats the attached disk to that size. If the given size exceeds that of the disk, Bad Things will happen but no errors will be generated. You have been warned. The size should be the total size of the disk, without worrying about headers vs. data space.
;: Returns nothing. The loaded disk block on return is undefined.

:fs.format
; Needs to populate the header and block bitmap blocks (mark the header blocks as used, and all nonexistent blocks at the end as used as well).
; Also must define the inode for the root directory, inode 0.

SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y
SET PUSH, Z
SET PUSH, I

SET X, A ; Set aside the size.
SET A, 0
JSR disk.read ; Read the first block of the disk.

SET A, [disk.mmr]

SET [A], 0x6201 ; Magic number, version 1 of CEFS.
SET [A+1], X ; Number of blocks on the disk.
SET [A+2], 12 ; Number of blocks which are used: 1 header, 4 block bitmap, 4 inode bitmap, 1 inode meta table, 1 inode table, 1 data block (root dir)
SET [A+3], 1 ; Number of used inodes (1, the root dir).

SET A, 0
JSR disk.write ; Write out the header block.

; Reg plan: I holds the block number, B the word number, X the size in blocks, C the current block. Y and Z are used for scratch.
; This code fills the bitmap coarsely, ignoring the beginning 12 used blocks and the tricky block at the seam. Those two words are set after the loop.

SET C, 0
SET I, 1
:fs.format.usedBlocksLoop
  SET B, 0
  :fs.format.usedWordsLoop
    SET Y, 0xffff ; used
    IFG X, C
      SET Y, 0 ; free

    SET Z, [disk.mmr]
    ADD Z, B
    SET [Z], Y

    ADD B, 1
    ADD C, 16
    IFG 1024, B
      SET PC, fs.format.usedWordsLoop

  SET A, I
  JSR disk.write
  ADD I, 1
  IFG 5, I
    SET PC, fs.format.usedBlocksLoop

; Now write the first word again
SET A, 1
JSR disk.read
SET A, [disk.mmr]
SET [A], 0x0fff ; First 12 blocks used.
SET A, 1
JSR disk.write ; Write it back.


; Now to compute the troublesome word of the bitmap directly from the size.
SET A, X
SHR A, 13 ; 0-3 for the block number
ADD A, 1
SET I, A ; I holds the block number
JSR disk.read

SET B, X
AND B, 0x000f ; size mod 16
SET Y, 0xffff
SHR Y, B ; Shift it down
SHL Y, B ; And back, leaving the bottom B bits 0 and the rest 1, as desired.
; Y holds the value to store.

SET A, X
SHR A, 4 ; The word to set, from 0
AND A, 0x03ff ; The offset into the block.

ADD A, [disk.mmr] ; A is now pointing at the spot.
SET [A], Y ; Write the value.

SET A, I ; The block number.
JSR disk.write ; And done.


; Now to set up the inode tables. I holds the block number, B the word. All are set to 0000.
SET I, 5
:fs.format.usedInodeBlockLoop
SET B, [disk.mmr]
:fs.format.usedInodeWordLoop
SET [B], 0
ADD B, 1
IFG [disk.mmrTop], B
  SET PC, fs.format.usedInodeWordLoop

SET A, I
JSR disk.write
ADD I, 1
IFG 9, I
  SET PC, fs.format.usedInodeBlockLoop

; There, all the inode bitmap is zeroed. Now mark the first inode as used.
SET A, 5
JSR disk.read
SET A, [disk.mmr]
SET [A], 1 ; inode 0 is used.
SET A, 5
JSR disk.write

; Now write the inode meta table
SET A, [disk.mmr]
:fs.format.inodeMetaLoop
SET [A], 0
ADD A, 1
IFG [disk.mmrTop], A
  SET PC, fs.format.inodeMetaLoop

SET A, [disk.mmr]
SET [A], 10 ; first inode table block
SET A, 9
JSR disk.write ; Write out the inode meta table.


; Now write the inode for the root directory.
SET A, [disk.mmr]
SET [A], 2 ; Type 2, directory.
SET [A+1], 1 ; One link
SET [A+2], 1 ; One block
SET [A+3], 8 ; Size low word (next, inode, length, 1-word string, twice)
SET [A+4], 0 ; Size high word
SET [A+5], 0 ; Reserved word
SET [A+6], 11 ; Block 11

SET A, 10
JSR disk.write ; write out the inode table.

SET A, [disk.mmr]
SET [A], 4 ; offset to next entry
SET [A+1], 0 ; Inode number
SET [A+2], 1 ; Length of string
SET [A+3], 0x002e ; packed string for .

SET [A+4], 0 ; offset to next entry (none)
SET [A+5], 0 ; inode number
SET [A+6], 1 ; Lenght of string (in words)
SET [A+7], 0x2e2e ; packed string for ..

SET A, 11
JSR disk.write ; and write the directory entry.

:fs.format.done

SET I, POP
SET Z, POP
SET Y, POP
SET X, POP
SET C, POP
SET B, POP
SET PC, POP

