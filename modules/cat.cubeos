;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT ; CAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# CAT
;:**CAT** is the default file system for cubeOS. It is based on the [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format. CubeOS uses hashes to identify links, in addition to fourteen character strings.
;:
;:**requires**
;:
;:- crypt
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**

;:## cat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a cat filesystem with the given *sectorSize*.
;:
;:Currently unsafe if the number of sectors is greater than 16
;:**returns** location of first word in header
;:

;SHOULD KEEP TRACK OF WHERE FILESYSTEM IS SO IT CAN ADD NEW STRIPS AND DO SEARCHES

:cat.mountSystem
SET [env.fs], A

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:cat.mountSystem.initHeader
STI [I], 0xC001 ;magic number, cat v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sectors start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:cat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:cat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess sectors to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, cat.mountSystem.initSectorMap.end

SUB B, 16 ;CAN WRAP AND BE UNSAFE
SET PC, cat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:cat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:cat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:cat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, cat.mountSystem.initSectorJoin.loop

:cat.mountSystem.initSectors
SET [A+4], I

:cat.mountSystem.initializeRoot
STI [I], 1 ;inode is a directory (root directory)
STI [I], 0
STI [I], 32

STI [I], 0 ;link directs here
STI [I], 0x2E ; "."
STI [I], 0
STI [I], 0 ;4
STI [I], 0
STI [I], 0
STI [I], 0
STI [I], 0 ;8
STI [I], 0
STI [I], 0
STI [I], 0
STI [I], 0 ;12
STI [I], 0
STI [I], 0
STI [I], 0
STI [I], 0 ;16

:cat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:## cat.findStrip (index)
;:Finds the location in memory of the first word in a strip at the index given.
;:
;:**returns** first word of header inode of the strip at *index*
;:

:cat.findStrip


;:## cat.newInode (location, type, length)
;:Creates a new inode at *location*.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:
;:**returns** location after inode

:cat.newInode
SET [A], B
ADD A, 2
SET [A], C
ADD A, 2
SET PC, POP
 ;

;:## cat.newLink (stripSource, stripTarg, nameLocation)
:cat.newLink
