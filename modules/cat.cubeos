;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT ; CAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# CAT
;:**CAT** is the default file system for cubeOS. It is based on the [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format.
;:
;:In order to act on a file or directory, it must be "opened." This copies the inode's contents to a temporary position (as provided by the program opening it.) Some of the subroutines below act on opened directories, so as to add links. When one is finished with a directory or file, one must "write" it back into its strip.
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**
;:

:cat.def.curDir DAT ".", 0 ;stock current directory name
:cat.def.parDir DAT "..", 0 ;stock parent directory name

;:## High-level Commands
;:The high-level commands provide a smooth interface with the filesystem that can be used easily by modules and the rest of the operating system.
;:



;:## Low-level Commands
;:The low-level commands are used by the high level commands to provide fast and efficient access to the framework of the filesystem itself.
;:

;:### cat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a cat filesystem with the given *sectorSize*.
;:
;:Currently unsafe if the number of sectors is greater than 16
;:**returns** location of first word in header
;:

;SHOULD KEEP TRACK OF WHERE FILESYSTEM IS SO IT CAN ADD NEW STRIPS AND DO SEARCHES

:cat.mountSystem
SET [env.fs], A

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A ;store location for retrieval at the end
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:cat.mountSystem.initHeader
STI [I], 0xC001 ;magic number, cat v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sector start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:cat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:cat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess bits to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, cat.mountSystem.initSectorMap.end

SUB B, 16
SET PC, cat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:cat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:cat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:cat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, cat.mountSystem.initSectorJoin.loop

:cat.mountSystem.initSectors
SET [A+4], I

:cat.mountSystem.initializeRoot
SET A, 0
SET B, 1
JSR cat.newInode

SET A, 0
SET B, 0
SET C, cat.def.curDir
JSR cat.newLink

SET A, 0
SET B, 1
SET C, temp.cat.directoryName
JSR cat.newLink

SET A, 1
SET B, 2
JSR cat.newInode

SET PC, cat.mountSystem.exit

:temp.cat.directoryName DAT "test"
:temp.cat.fileContent DAT "This is a test."

:cat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### cat.open (stripStartSector, continuousMemoryLocation)
;:Obeying sector joins, copies the entire file or directory (including inode) specified by *stripStartSector* to *continuousMemoryLocation*.
;:
:cat.open
SET PUSH, I
SET PUSH, A

JSR cat.getSectorPointer ;only modifies A
SET I, [A+2] ;set I to the content length
ADD I, 4 ;add the inode length

SET A, POP

:cat.open.loop
SET PUSH, A ;store A for looping

JSR cat.getJoinedSector
IFE A, 0
  SET PC, cat.open.exit

SET C, [env.fs]
SET C, [C+5]

SUB I, C ;subtract from the total length
;rather than subtracting every time, one could do MOD and use the remainder for copying the very end of the strip

JSR cat.getSectorPointer ;only modifies A; get literal memory location

JSR typ.pCopy ;copy the sector
SET B, A ;put the copy continue location in B

SET A, POP
JSR cat.getJoinedSector
SET PC, cat.open.loop

:cat.open.exit
SET A, POP
JSR cat.getSectorPointer

SET C, I
JSR typ.pCopy

SET I, POP
SET PC, POP
 ;

;:### cat.getJoinedSector (sectorNumber)
;:**modifies** A
;:**returns** the sector joined to *sectorNumber*, or **0** if unjoined or unused
;:
:cat.getJoinedSector
SET PUSH, B
SET B, [env.fs]sector joins start
ADD B, [B+3]
ADD B, A
SET A, [B]
SET B, POP
SET PC, POP
 ;

;:### cat.getOpenSector ()
;:Finds the first open sector in the filesystem
;:**modifies** A
;:**returns** sector number
;:
:cat.getOpenSector
SET PUSH, B
SET PUSH, C
SET PUSH, I

SET A, [env.fs]
SET B, [A+2] ;starting location
SET C, [A+3] ;ending location

:cat.getOpenSector.wordloop
SET A, [C]

;CHECK THROUGH AND FIND THE FIRST OPEN SECTOR

SET I, POP
SET C, POP
SET B, POP
 ;

;:### cat.getSectorPointer (sector)
;:**modifies** A
;:**returns** a pointer to the location of the given sector in memory
;:
:cat.getSectorPointer
SET PUSH, B
SET B, [env.fs]
MUL A, [B+5] ;multiply by sector size
ADD A, [B+4] ;add sector offset
SET B, POP
SET PC, POP
 ;

;:### cat.newInode (sector, type)
;:Creates a new inode of *type* and length 0 at *sector*. It also marks the corresponding sector in sector map as used.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:**modifies** A, B
;:**returns** sector of inode

:cat.newInode
SET PUSH, A ;store A for returning
JSR cat.getSectorPointer ;make A a pointer to the start of that sector

SET [A], B
SET [A+1], 0 ;the number of links pointing to the inode
SET [A+2], 0 ;the number content size
SET [A+3], 0 ;reserved

SET A, POP
SET PC, POP
 ;

;:### cat.newLink (directoryPointer, targetStripStartSector, namePointer)
;:Creates a new link under the given sector, extending the length of the inode automatically <strike>and overflowing to the next open sector (updating sector usage and linking) if necessary</strike>.
;:The first word is the *targetStripStartSector*, and the remaining fifteen words are copied literally <strike>(maximum length fourteen)</strike> from the null-terminated word at *namePointer*.
;:**returns** 0 if successful, and 1 if the given sector does not contain a directory
;:
:cat.newLink
IFN [A], 1 ;if the sector does not contain a directory
  SET PC, exf ;exit false

SET PUSH, A ;store A for later

ADD A, [A+2] ;add the length of the existing links
ADD A, 4 ;add the length of the inode
;SHOULD CHECK TO SEE IF IT IS OUT OF BOUNDS OF THE SECTOR; IF SO, IT MUST CONTINUE ON TO EITHER THE LINKED SECTOR OR LINK ANOTHER

SET [A], B ;set the link target
ADD A, 1
SET B, C

JSR typ.cCopy ;SHOULD IMPOSE MAXIMUM LENGTH

SET A, POP
ADD [A+2], 16 ;add the length of the link (always 16) to the length of the inode
SET PC, ext ;exit successful
 ;
