;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT ; CAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# CAT
;:**CAT** is the default file system for cubeOS. It is based on the [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format.
;:
;:In order to act on a file or directory, it must be "opened." This copies the inode's contents to a temporary position (as provided by the program opening it.) Some of the subroutines below act on opened directories, so as to add links. When one is finished with a directory or file, one must "write" it back into its strip.
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**
;:

:cat.def.curDir DAT ".", 0 ;stock current directory name
:cat.def.parDir DAT "..", 0 ;stock parent directory name

;:## High-level Commands
;:The high-level commands provide a smooth interface with the filesystem that can be used easily by modules and the rest of the operating system.
;:



;:## Low-level Commands
;:The low-level commands are used by the high level commands to provide fast and efficient access to the framework of the filesystem itself.
;:

;:### cat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a cat filesystem with the given *sectorSize*.
;:
;:Currently unsafe if the number of sectors is greater than 16
;:**returns** location of first word in header
;:

;SHOULD KEEP TRACK OF WHERE FILESYSTEM IS SO IT CAN ADD NEW STRIPS AND DO SEARCHES

:cat.mountSystem
SET [env.fs], A

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A ;store location for retrieval at the end
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:cat.mountSystem.initHeader
STI [I], 0xC001 ;magic number, cat v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sector start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:cat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:cat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess bits to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, cat.mountSystem.initSectorMap.end

SUB B, 16
SET PC, cat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:cat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:cat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:cat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, cat.mountSystem.initSectorJoin.loop

:cat.mountSystem.initSectors
SET [A+4], I

:cat.mountSystem.initializeRoot
SET A, 0
SET B, 1
JSR cat.newInode

;TEST LINK

;cat.newInode returns the affected sector
JSR cat.getSectorPointer ;pointer to root
ADD A, 3 ;inode content length

SET [A], 32
ADD A, 1 ;go to first word after inode

SET B, A
SET A, temp.cat.testLink
SET C, 32
JSR typ.pCopy

SET PC, cat.mountSystem.exit

:temp.cat.testLink
DAT 1, "TestDir", 0, 0, 0, 0, 0, 0, 0, 0
DAT 2, "TestFile", 0, 0, 0, 0, 0, 0, 0

:cat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### cat.open (stripStartSector, continuousMemoryLocation)
;:Obeying sector joins, copies the entire file or directory (including inode) specified by *stripStartSector* to *continuousMemoryLocation*.
;:
:cat.open
SET PUSH, I
SET PUSH, A

JSR cat.getSectorPointer ;only modifies A
SET I, [A+3] ;set I to the content length
ADD I, 4 ;add the inode length

SET A, POP

:cat.open.loop
SET PUSH, A ;store A for looping

JSR cat.getJoinedSector

IFE A, 0
  SET PC, cat.open.exit

SET C, [env.fs]
SET C, [C+5]

SUB I, C ;subtract from the total length
;rather than subtracting every time, one could do MOD and use the remainder for copying the very end of the strip

JSR cat.getSectorPointer ;only modifies A; get literal memory location

JSR typ.pCopy ;copy the sector
SET B, A ;put the copy continue location in B

SET A, POP
JSR cat.getJoinedSector
SET PC, cat.open.loop

:cat.open.exit
SET A, POP
JSR cat.getSectorPointer

SET C, I
SET Z, C
JSR typ.pCopy

SET I, POP
SET PC, POP
 ;

;:### cat.write (inputPointer, sectorNumber)
;:Obeying sector joins, copies the entire contents of an open file at *inputPointer* to the sector at *sectorNumber*, linking new sectors as needed and unlinking old ones if they become unnecessary.
;:**under development**
;:
:cat.write
SET PUSH, I
SET PUSH, J
SET PUSH, X

SET J, [env.fs]
SET J, [J+5] ;set C to the size of a sector

SET I, [A+3] ;set A to the size of the input
ADD I, 4 ;include the size of the inode

SET PUSH, I ;store the size of the input for later

DIV I, J ;set I to the number of sectors needed for the whole file
ADD I, 1 ;DIV rounds down ;FIND A RELIABLE WAY TO DO THIS

SET X, A ;make X the storage place for the current input index

:cat.write.loop
IFE I, 1
  SET PC, cat.write.exit

SET PUSH, B ;store the current sector number

SET A, B
JSR cat.getSectorPointer ;get the location of the sector in memory
SET B, A


SET A, X ;set A to the location for input in the copy
SET C, J 
JSR typ.pCopy ;returns the output location

ADD X, J ;make X the location of the remaining part of the file
SUB I, 1 ;reduce the number of remaining sectors to copy by 1

SET A, POP ;restore the number of the sector that was just written to
JSR cat.linkNewSector ;link a new sector if one is not already linked

SET B, A ;set B to the next sector to write to

SET PC, cat.write.loop

:cat.write.exit
SET C, POP ;restore the size of the input
MOD C, J ;make C the leftover size

SET A, B
JSR cat.getSectorPointer
SET B, A

SET A, X
JSR typ.pCopy

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### cat.linkNewSector (sectorNumber)
;:If **sectorNumber** does not link to another sector, link the first open sector to it.
;:
;:**modifies** A <br />
;:**returns** the sector number joined
;:
:cat.linkNewSector
SET PUSH, B
SET B, [env.fs]
SET B, [B+3]

ADD B, A
IFN [B], 0 ;if the sector is already linked, just return with that value.
  SET PC, cat.linkNewSector.exit

;if it's not already linked, do the following

JSR cat.getOpenSector ;modifies A; get the first open sector from the bitmap
JSR cat.markSectorUsed ;returns the sector; mark that sector used

SET [B], A ;link the new sector

:cat.linkNewSector.exit
SET A, [B]
SET B, POP
SET PC, POP
 ;

;:### cat.getJoinedSector (sectorNumber)
;:**modifies** A <br />
;:**returns** the sector joined to *sectorNumber*, or **0** if unjoined or unused
;:
:cat.getJoinedSector
SET PUSH, B
SET B, [env.fs] ;sector joins start
SET B, [B+3]
ADD B, A
SET A, [B]
SET B, POP
SET PC, POP
 ;

;:### cat.getOpenSector ()
;:Finds the first open sector in the filesystem. **Does not detect when the system is full.**
;:
;:**modifies** A
;:**returns** sector number
;:
:cat.getOpenSector
SET PUSH, B
SET PUSH, C
SET PUSH, I

SET A, [env.fs]
SET B, [A+2] ;starting location
;SET C, [A+3] ;ending location

:cat.getOpenSector.wordloop
SET A, [B]
SET C, 0x8000 ;0b1000 0000 0000 0000

:cat.getOpenSector.bitloop
IFC C, A ;if C & A == 0
  SET PC, cat.getOpenSector.exit

ADD I, 1

IFE C, 0x0001 ;0b0000 0000 0000 0001
  SET PC, cat.getOpenSector.nextWord ;get the next word in the map

SHR C, 1
SET PC, cat.getOpenSector.bitloop

:cat.getOpenSector.nextWord
ADD B, 1
SET PC, cat.getOpenSector.wordloop

:cat.getOpenSector.exit
SET A, I

SET I, POP
SET C, POP
SET B, POP
SET PC, POP
 ;

;:### cat.getSectorPointer (sector)
;:**modifies** A
;:**returns** a pointer to the location of the given sector in memory
;:
:cat.getSectorPointer
SET PUSH, B
SET B, [env.fs]
MUL A, [B+5] ;multiply by sector size
ADD A, [B+4] ;add sector offset
SET B, POP
SET PC, POP
 ;

;:### cat.newInode (sector, type)
;:Creates a new inode of *type* and length 0 at *sector*. It also marks the corresponding sector in sector map as used.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:
;:**modifies** A, B <br />
;:**returns** the sector of the inode

:cat.newInode
SET PUSH, C
SET PUSH, A ;store A for returning
JSR cat.getSectorPointer ;make A a pointer to the start of that sector

SET [A], B
SET [A+1], 0 ;the number of links pointing to the inode
SET [A+2], 0 ;reserved high order word content size
SET [A+3], 0 ;low order word content size

SET A, PEEK
SHR A, 4 ;divide by 16

SET B, [env.fs]
SET B, [B+2] ;set B to the location of the sector map

ADD B, A ;set B to the location of the relavent word of the sector map

SET A, PEEK
AND A, 0x000f ;set A to the index of the relevant bit

SET C, 0x8000 ;0b1000 0000 0000 0000
SHR C, A ;make the relevant bit of C 1

BOR [B], C ;set the relevant bit of B to 1

SET A, POP
SET C, POP
SET PC, POP
 ;

;:### cat.rmInode (sector)
;:Marks *sector* unused in the sector map, <strike>unlinks the rest of the strip</strike>, and marks its inode unused.
;:
;:**modifies** A <br />
;:**returns** *sector*
;:
:cat.rmInode
SET PUSH, C
SET PUSH, B
SET PUSH, A ;store A for returning

JSR cat.getSectorPointer ;get the sector in memory
SET [A], 0 ;mark the inode unused

SET A, PEEK
JSR cat.freeStrip

SET A, POP
SET B, POP
SET C, POP
SET PC, POP
 ;

;:### cat.freeStrip (startSector)
;:Unlinks all of the sectors in a strip and marks them each as free
;:
:cat.freeStrip
SET C, [env.fs]
SET C, [C+3] ;set I to the sector joins start

:cat.freeStrip.loop
SET B, C
ADD B, A ;set B to the location of the sector's join

JSR cat.markSectorUnused ;marks the sector unused in the bitmap
;without changing registers

IFE [B], 0
  SET PC, POP

SET A, [B]
SET [B], 0
SET PC, cat.freeStrip.loop
 ;

;:### cat.markSectorUsed (sector)
;:Marks a sector used in the bitmap.
;:
;:**modifies** A <br />
;:**returns** *sector*
;:
:cat.markSectorUsed
SET PUSH, C
SET PUSH, B
SET PUSH, A ;store for reusage

SHR A, 4 ;divide by 16

SET B, [env.fs]
SET B, [B+2] ;set B to the location of the sector map

ADD B, A ;set B to the location of the relavent word of the sector map

SET A, PEEK
AND A, 0x000f ;set A to the index of the relevant bit

SET C, 0x8000 ;0b1000 0000 0000 0000
SHR C, A ;make the relevant bit of C 1

BOR [B], C ;set the relevant bit of B to 0
SET A, POP
SET B, POP
SET C, POP
SET PC, POP
 ;

;:### cat.markSectorUnused (sector)
;:Marks a sector unused in the bitmap.
;:
;:**modifies** A <br />
;:**returns** *sector*
;:
:cat.markSectorUnused
SET PUSH, C
SET PUSH, B
SET PUSH, A ;store for reusage

SHR A, 4 ;divide by 16

SET B, [env.fs]
SET B, [B+2] ;set B to the location of the sector map

ADD B, A ;set B to the location of the relavent word of the sector map

SET A, PEEK
AND A, 0x000f ;set A to the index of the relevant bit

SET C, 0x8000 ;0b1000 0000 0000 0000
SHR C, A ;make the relevant bit of C 1
XOR C, 0xffff ;negate C, so the relevant bit is 0

AND [B], C ;set the relevant bit of B to 0
SET A, POP
SET B, POP
SET C, POP
SET PC, POP
 ;


;:### cat.newLink (directoryPointer, targetStripStartSector, namePointer)
;:Creates a new link under the given sector, extending the length of the inode automatically <strike>and overflowing to the next open sector (updating sector usage and linking) if necessary</strike>.
;:The first word is the *targetStripStartSector*, and the remaining fifteen words are copied literally <strike>(maximum length fourteen)</strike> from the null-terminated word at *namePointer*.
;:**returns** 0 if successful, and 1 if the given sector does not contain a directory
;:
:cat.newLink
IFN [A], 1 ;if the sector does not contain a directory
  SET PC, exf ;exit false

SET PUSH, A ;store A for later

ADD A, [A+2] ;add the length of the existing links
ADD A, 4 ;add the length of the inode
;SHOULD CHECK TO SEE IF IT IS OUT OF BOUNDS OF THE SECTOR; IF SO, IT MUST CONTINUE ON TO EITHER THE LINKED SECTOR OR LINK ANOTHER

SET [A], B ;set the link target
ADD A, 1
SET B, C

JSR typ.cCopy ;SHOULD IMPOSE MAXIMUM LENGTH

SET A, POP
ADD [A+2], 16 ;add the length of the link (always 16) to the length of the inode
SET PC, ext ;exit successful
 ;
