;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CAT ; CAT FileSystem         ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# CAT
;:**CAT** is the default file system for cubeOS. It is based on the [Harry's Allocation Table](https://github.com/0x10cStandardsCommittee/0x10c-Standards/blob/master/FS/Draft_Harrys_Allocation_Table.txt) file system format. cubeOS uses hashes to identify links, in addition to fourteen character strings.
;:
;:**requires**
;:
;:- crypt
;:
;:**STILL UNDER HEAVY DEVELOPMENT. DO NOT USE**

:cat.def.curDir DAT ".", 0 ;stock current directory name
:cat.def.parDir DAT "..", 0 ;stock parent directory name

;:## High-level Commands
;:The high-level commands provide a smooth interface with the filesystem that can be used easily by modules and the rest of the operating system.
;:



;:## Low-level Commands
;:The low-level commands are used by the high level commands to provide fast and efficient access to the framework of the filesystem itself.
;:

;:### cat.mountSystem (location, length, sectorSize)
;:Mounts */* directory at *location*, reserving *length* words after it. It then initializes a cat filesystem with the given *sectorSize*.
;:
;:Currently unsafe if the number of sectors is greater than 16
;:**returns** location of first word in header
;:

;SHOULD KEEP TRACK OF WHERE FILESYSTEM IS SO IT CAN ADD NEW STRIPS AND DO SEARCHES

:cat.mountSystem
SET [env.fs], A

SET PUSH, I
SET PUSH, J
SET PUSH, X
SET PUSH, A ;store location for retrieval at the end
SET I, A
DIV B, C ;make B the maximum number of sectors ;SHOULD 

;should find the maximum number of sectors, but doesn't

:cat.mountSystem.initHeader
STI [I], 0xC001 ;magic number, cat v1.0
STI [I], B ;number of sectors
STI [I], 0 ;reserved for sector map start
STI [I], 0 ;reserved for sector joins start
STI [I], 0 ;reserved for sector start
STI [I], C ;sector size
STI [I], 0 ;sectors in use

:cat.mountSystem.initSectorMap
SET [A+2], I ;sector map start
SET PUSH, B ;store B
SET C, B ;we will change B later
DIV C, 16 ;find number of words needed to represent sector use states
;OPTIMIZE DIV WITH SHR
ADD C, I ;C becomes sector map end location

:cat.mountSystem.initSectorMap.loop
SET X, 0xFFFF ;make X initializer for sector map
SHR X, B ;set only the excess bits to used
STI [I], X

IFG X, 0 ;exit if that was enough bits to represent all sectors
  SET PC, cat.mountSystem.initSectorMap.end

SUB B, 16
SET PC, cat.mountSystem.initSectorMap.loop ;COULD BE REORDERED MORE EFFICIENTLY

:cat.mountSystem.initSectorMap.end
SET B, POP ;restore number of sectors

:cat.mountSystem.initSectorJoin
SET [A+3], I ;sector join start
ADD B, I ;make B the ending location of sector join

:cat.mountSystem.initSectorJoin.loop
STI [I], 0
IFN I, B ;continue reserving until I reaches the end location
  SET PC, cat.mountSystem.initSectorJoin.loop

:cat.mountSystem.initSectors
SET [A+4], I

:cat.mountSystem.initializeRoot
SET A, 0
SET B, 1
JSR cat.newInode

SET A, 0
SET B, 0
SET C, cat.def.curDir
JSR cat.newLink

SET A, 0
SET B, 1
SET C, temp.cat.directoryName
JSR cat.newLink

SET A, 1
SET B, 2
JSR cat.newInode

SET PC, cat.mountSystem.exit

:temp.cat.directoryName DAT "test"
:temp.cat.fileContent DAT "This is a test."

:cat.mountSystem.exit
SET A, POP ;return location

SET X, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### cat.getOpenSector ()
;:Finds the first open sector in the filesystem
;:**modifies** A
;:**returns** sector number
;:
:cat.getOpenSector
SET PUSH, B
SET PUSH, C
SET PUSH, I

SET A, [env.fs]
SET B, [A+2] ;starting location
SET C, [A+3] ;ending location

:cat.getOpenSector.wordloop
SET A, [C]

;CHECK THROUGH AND FIND THE FIRST OPEN SECTOR

SET I, POP
SET C, POP
SET B, POP

;:### cat.getSectorPointer (sector)
;:**modifies** A
;:**returns** a pointer to the location of the given sector in memory
;:
:cat.getSectorPointer
SET PUSH, B
SET B, [env.fs]
MUL A, [B+5] ;multiply by sector size
ADD A, [B+4] ;add sector offset
SET B, POP
SET PC, POP
 ;

;:### cat.getInodePointer (inodeNumber)
;:Obeys sector links to find pointer to inode.
;:**returns** pointer to the location of the given inode in memory
;:**UNDER DEVELOPMENT**
;:
:cat.getInodePointer
SET PUSH, I

SET B, [env.fs+3] ;make B a pointer to the sector joins start


;:### cat.newInode (sector, type)
;:Creates a new inode of *type* and length 0 at *sector*. It also marks the corresponding sector in sector map as used.
;:Types are 0, for unused, 1, for directory, and 2, for file.
;:**modifies** A, B
;:**returns** sector of inode

:cat.newInode
SET PUSH, A ;store A for returning
JSR cat.getSectorPointer ;make A a pointer to the start of that sector

SET [A], B
SET [A+1], 0 ;the number of links pointing to the inode
SET [A+2], 0 ;the number content size
SET [A+3], 0 ;reserved

SET A, POP
SET PC, POP
 ;

;:### cat.newLink (sector, targetSector, namePointer)
;:Creates a new link under the given sector, extending the length of the inode automatically <strike>and overflowing to the next open sector (updating sector usage and linking) if necessary</strike>.
;:The first word is the *targetSector*, and the remaining fifteen words are copied literally <strike>(maximum length fourteen)</strike> from the null-terminated word at *namePointer*.
;:**returns** 0 if successful, and 1 if the given sector does not contain a directory
;:
:cat.newLink
JSR cat.getSectorPointer ;get the memory location 

IFN [A], 1 ;if the sector does not contain a directory
  SET PC, exf ;exit false

SET PUSH, A ;store A for later

ADD A, [A+2] ;add the length of the existing links
ADD A, 4 ;add the length of the inode
;SHOULD CHECK TO SEE IF IT IS OUT OF BOUNDS OF THE SECTOR; IF SO, IT MUST CONTINUE ON TO EITHER THE LINKED SECTOR OR LINK ANOTHER

SET [A], B ;set the link target
ADD A, 1
SET B, C

JSR typ.cCopy ;SHOULD IMPOSE MAXIMUM LENGTH

SET A, POP
ADD [A+2], 16 ;add the length of the link (always 16) to the length of the inode
SET PC, ext ;exit successful
 ;
