;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HEAPMAN ; Heap Manager   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# Heap Manager
;:
;:The heap is essentially a linked list of regions. Each region consists of a two-word header (see below) followed by the allocated memory.
;:
;:The header consists of a size for the region (not including the header) and a pointer to the header of the next region (0 for last region). The high bit of the size word is actually a flag, with 1 meaning the region is free, and 0 meaning it's in use.
;:

;:### heap.init
;:(location, length)
;:heap.init reserves a 2-word header. *length* is actually the length of the heap, excluding the header.
;:
;:The header consists of a magic word, **0x9ea9** and the location of the first heap region in memory.
;:
;:**The heap is not zeroed; the contents of newly allocated memory are arbitrary and undefined.**
;:
;:**returns** location of header
;:

:heap.init
SET [env.heap], A
ADD A, 2
SET [env.heap+1], A ; The address of the first region header.
SUB B, 2 ; Subtract the two bytes of the region header.
BOR B, 0x8000 ; Mark it as free.
SET [A], B
SET [A+1], 0 ; No next region.
SET PC, POP


;:### heap.alloc (length)
;:Reserves a consecutive block of *length* words of memory in the heap.
;:
;:Currently a bit dim; uses the first sufficiently large region, not necessarily the best one. This trades increased memory fragmentation for speed.
;:
;:**returns** the location of the reserved memory, or 0 if no block of the requested size could be found.
;:
:heap.alloc
; Walks the pointers with X to find a free region
SET PUSH, B
SET PUSH, C
SET PUSH, X
SET PUSH, Y

SET X, [env.heap+1] ; Retrieve the address of the first region header.

:heap.alloc.search
SET Y, [X]
SET C, Y
AND Y, 0x8000 ; Retrieve the free flag
AND C, 0x7fff ; And the size
ADD C, 1 ; Add 1 so we can use IFG below but avoid the off-by-one error.
IFG Y, 0
	IFG C, A
		SET PC, heap.alloc.found
SET X, [X+1] ; X now points at the next region's header
IFG X, 0
  SET PC, heap.alloc.search

; If we fell through to here, X is 0, so we haven't found a big enough region.
SET A, 0xfffe ; Will be turned to 0 by the ADD A, 2 in heap.alloc.done. HACK
SET PC, heap.alloc.done

:heap.alloc.found
; At this point, X points at the region header, C holds the size+1, and B and Y are junk.
; Write the new length, and set the pointer.
SUB C, 3 ; 1 for the above fudge, 2 for the new header.
SUB C, A ; C now holds the size of the new, following free region.

SET [X], A ; Store the length of this region.
SET Y, X
ADD Y, A
ADD Y, 2 ; Y now points at the header of the following, free region.
SET A, X
SET X, [X+1] ; X now points at the next-next region, after the newly created free region in Y.
SET [A+1], Y ; Store the pointer to the following, free region.

SET B, X
SUB B, Y ; The difference between the two pointers
IFG 3, B ; If the difference between the pointers to the next and next-next regions is < 3, there's no room for data.
	SET PC, heap.alloc.emptyNext

; If we come here, the next region is of a workable size, so set it up.
BOR C, 0x8000 ; Set the free flag.
SET [Y], C
SET [Y+1], X
SET PC, heap.alloc.done


:heap.alloc.emptyNext
; Here, the supposed free region is too small to hold a header and data, so we roll it into this region.
; At this point A is the new region, Y the next (too-small, free) region, X the next-next region.
SET C, X
SUB C, A
SUB C, 2 ; C is now the new size of the new region.
SET [A], C

:heap.alloc.done
ADD A, 2 ; A now points at the new memory for returning to the user.
SET Y, POP
SET X, POP
SET C, POP
SET B, POP
SET PC, POP



;:### heap.free (location, length)
;:Marks the blocks specified by *location* and *length* as free, and clears them.
;:
;:**returns** *location*
;:
:heap.free
SET PUSH, B
SET PUSH, A

SET C, [env.heap]

SUB A, [C+1] ;subtract the first block's location from A
DIV A, [C+2] ;divide by the size of a block, to get the
             ;block index, rounding down

;DIV A, [C+2] not coming out evenly (EX != 0) implies corruption
;of some sort. Impose a check here?

DIV B, [C+2] ;make B the number of blocks implied by *length*
IFN EX, 0    ;rounding up, as the allocation subroutine does
  ADD B, 1

SET C, 0 ;"unused"
JSR heap.mark

SET A, POP
SET B, POP
ADD B, A
ADD B, 1
SET C, A

:heap.free.clear
SET [A], 0
ADD A, 1
IFN A, B
SET PC, heap.free.clear

SET PC, POP
 ;

;:### heap.mark (block, number, used/unused)
;:Marks *number* of blocks used or unused, starting from the index *block*. `1` in *used/unused* denotes `used`, and `0` denotes `unused`.
;:
;:**return** *block*
;:
:heap.mark
SET PUSH, A
SET PUSH, X
SET X, [env.heap]
ADD X, 4 ;make X a pointer to the first word in the bitmap

SUB B, 1 ;for use later
SET PUSH, C ;store used/unused type
SET PUSH, B ;store B
SET PUSH, A ;store A

SHR A, 4 ;divide by 16, to get the word index
ADD A, X ;make A a pointer to the relevant word

SET B, POP ;restore the block index
AND B, 0x000f ;get the bit index

SET C, 0x8000 ;set the leftmost bit
ASR C, POP    ;make the leftmost *number* bits 1

SHR C, B ;make C apply to all of the blocks to be reserved

SET B, POP ;restore used/unused
IFE B, 1
  SET PC, heap.mark.used

:heap.mark.unused
XOR C, 0xffff ;flip the bits to reflect what needs to be changed
AND [A], C    ;set the bits that need to be changed to 0

SET X, POP
SET A, POP
SET PC, POP

:heap.mark.used
BOR [A], C ;set the bits that need to be changed to 1

SET X, POP
SET A, POP ;return *blocks*
SET PC, POP
 ;
 ;;
