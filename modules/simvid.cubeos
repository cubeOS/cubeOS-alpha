;;;;;;;;;;;;;;;;;;;;;;;;;;
; SIMVID ; Video Manager ;
;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.scrnLoc DAT 0
:v.scrnEnd DAT 0
:v.scrnHeight DAT 12
:v.scrnWidth DAT 32

;:### sv.init (videoRAMPointer, fontRAMPointer)
;:Maps the screen's font to *fontRAMPointer* and the screen's video ram to *videoRAMPointer* in that order.
;:
:sv.init

SET PUSH, A
SET A, 1
HWI [HW.LEM1802] ;MEM_MAP_FONT

SET B, POP
SET A, 0
HWI [HW.LEM1802] ;MEM_MAP_SCREEN

SET [v.scrnLoc], B
ADD B, 0x180
SET [v.scrnEnd], B
SET PC, POP
 ;

;:### sv.newWindow
;:Reserves screen space in the heap, maps the screen to it.
;:
;:**returns** the first index in the new screen location
;:
:sv.newWindow
SET A, 0x120
JSR tusk.getMem ;reserve 384 words

SET B, A
SET A, 0
HWI [HW.LEM1802] ;remap the screen to this heap location

SET A, B ;return the location of the screen
SET PC, POP

;:### sv.write (inputPointer, outputPointer)
;:Writes ASCII to the screen using special characters to act as directives. (This does not perform preprocessing such as translating normal ASCII into those special characters.) Special characters are as follows.
;:**returns** the location of the null following the written text
;:
;:#### Color `0x01`
;:Substitutes the first nine bits of every word following this with the first nine bits of this word.
;:
;:
;:
:sv.write
IFC [A], 0x007F ;if the last 7 bits are 0b0000 000
  SET PC, sv.write.exitEarly ;exit early

SET PUSH, I
SET PUSH, J

SET I, A
SET J, B
SET [sv.write.v.color], 0xF000 ;default to white on black

:sv.write.loop
SET A, [I]
AND A, 0x007F

IFE A, 0x01
  SET PC, sv.write.s.color

BOR A, [sv.write.v.color]

STI [J], A ;set the destination to the processed source and increment destination pointer and source pointer

IFN [I], 0
  SET PC, sv.write.loop
  
SET [J], [I] ;write the terminating null

SET A, J
SET J, POP
SET I, POP
SET PC, POP

:sv.write.exitEarly
SET [B], 0x0000 ;make the first word in the output null
SET A, B ;return the index that sv.write would have written to
         ;if there had been content
SET PC, POP

:sv.write.s.color
SET [sv.write.v.color], [I]
AND [sv.write.v.color], 0xFF80 ;first 9 bits
ADD I, 1 ;increment the source, but not the destination
SET PC, sv.write.loop

:sv.write.v.color DAT 0
 ;
 
:sv.clear
SET PUSH, I
SET PUSH, J

SET I, [v.scrnLoc]

:sv.clear.loop
STI [I], 0

IFL I, [v.scrnEnd]
  SET PC, sv.clear.loop

SET J, POP
SET I, POP
SET PC, POP
 ;

:sv.getLoc ; (xOffset, yOffset)
IFL A, [v.scrnWidth]
  IFL B, [v.scrnHeight]
    SET PC, sv.getLoc.loc ;if onscreen, continue
SET PC, exf

:sv.getLoc.loc
MUL B, [v.scrnWidth] ;make yOffset a line index
ADD A, B              ;combine them
ADD A, [v.scrnLoc]    ;make the index an index onscreen
SET PC, POP           ;return in A
 ;

:sv.autoScroll ; () does not modify registers
SET PUSH, X

SET X, [v.scrnEnd]
SUB X, [v.scrnWidth]

IFE [X], 0
  SET PC, sv.autoScroll.ex

SET PUSH, I
SET PUSH, J
SET I, [v.scrnLoc]
SET J, I
ADD J, [v.scrnWidth]

:sv.autoScroll.loop
STI [I], [J]
IFN J, X
  SET PC, sv.autoScroll.loop

SET X, J
:sv.autoScroll.looplast
STI [I], [X]
SET [X], 0
ADD X, 1
IFG X, [v.scrnEnd]
  SET PC, sv.autoScroll.subex
SET PC, sv.autoScroll.looplast

:sv.autoScroll.subex
SET J, POP
SET I, POP

:sv.autoScroll.ex
SET X, POP
SET PC, POP
 ;

:sv.scrollUp
SET PUSH, I
SET PUSH, J

SET I, [v.scrnLoc]
SET J, I
ADD J, [v.scrnWidth]

:sv.scrollUp.loop
STI [I], [J]
IFL J, [v.scrnEnd]
  SET PC, sv.scrollUp.loop

:sv.scrollUp.clearLast
SET I, [v.scrnEnd]
SUB I, [v.scrnWidth]

:sv.scrollUp.clearLast.loop
STI [I], 0
IFL I, [v.scrnEnd]
  SET PC, sv.scrollUp.clearLast.loop

SET J, POP
SET I, POP
SUB I, [v.scrnWidth] ;adjust I for caller, hopefully
SET PC, POP
 ;
 
:sv.getNewLine ; (currentLoc)
SET PUSH, I
SET I, [v.scrnLoc]
JSR sv.autoScroll
SET PC, sv.getNewLine.loop.sub

:sv.getNewLine.loop
ADD I, [v.scrnWidth]

:sv.getNewLine.loop.sub
IFG A, I ;exit successful if line scrnindex >= currentindex
  SET PC, sv.getNewLine.loop

IFE I, [v.scrnEnd]
  SUB I, [v.scrnWidth]

SET A, I
SET I, POP
SET PC, POP
 ;
 ;;
