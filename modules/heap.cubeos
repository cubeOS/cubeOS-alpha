;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HEAPMAN ; Heap Manager   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;:# Heap Manager
;:
:heap.loc DAT 0

;:### heap.init
;:(location, length, blocksize)
;:heap.init reserves a 4 word header followed by a bit map of all blocks. The size of the bit map is (*maxlength*/*blocksize*). *length* is actually the length of the heap, excluding the header and bit map.
;:
;:The header consists of a magic word, **0x9ea9**, the location of the first block in memory, the size of each block, and the maximum length of the heap.
;:
;:**This subroutine clears all of the space given to it.**
;:
;:**returns** location of header
;:

:heap.init
SET PUSH, I
SET PUSH, J

SET A, PUSH
SET A, B

DIV A, C
DIV A, 16 ;OPTIMIZE WITH SHR

ADD A, PEEK
ADD A, 4 ;make A the location of the start of the first block

STI [I], 0x9EA9	;0
STI [I], A
STI [I], C
STI [I], B


SET I, A
ADD I, B ;create ending location

:heap.init.loop ;clear backwards
IFE I, A
  SET PC, heap.init.exit
STD [I], 0
SET PC, heap.init.loop

:heap.init.exit
SET A, POP
SET J, POP
SET I, POP
SET PC, POP
 ;

;:### heap.alloc (length)
;:Reserves the first consecutive *length* of memory in the heap.
;:
;:**returns** the location of the reserved memory, or 1 if no such block of memory is available
;:**UNDER DEVELOPMENT; DO NOT USE**
;:
SET B, [heap.loc+2] ;make B the length of the blocks
DIV A, B ;make A the number of blocks needed

;NEED TO FIND CONSECUTIVE OPEN BLOCKS
 ;;
