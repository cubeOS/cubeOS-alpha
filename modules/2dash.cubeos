;;;;;;;;;;;;;;;;
; DASH ; Shell ;
;;;;;;;;;;;;;;;;

:v.sPrompt DAT 0x2024
:v.promptLoc DAT 0

:v.stdin DAT 0xA00 ;SHOULD NOT HARDCODE
:v.stdout DAT 0xB00 ;SHOULD NOT HARDCODE

:v.cmdmem DAT 1 ;used in stupid way of "hashing" input
;SHOULD USE FOR HASH INSTEAD, BUT ONLY IF NECESSARY

;:### s.instance
;:Prepares a new terminal session at the root directory.
;:
;:1. Set *env.cwds* to "/ " in packed form (`0x202F`)
;:2. Clears the screen
;:3. Calls *s.takeIn*
;:4. Calls *s.parse*
;:5. Calls *s.stdout* with the argument being the cursor location when the user pressed enter
;:6. Loops nonendingly to 3
;:
:s.instance ;SHOULD PREPARE SDIN and SDOUT
SET [env.cwds], 0x202F
JSR sv.clear ;clear the screen
SET A, [v.scrnLoc]

:s.instance.promptLoop
JSR s.takeIn ;s.takeIn TAKES CURSOR ARGUMENT
SET PUSH, A ;keep track of cursor location

JSR s.parse

SET A, POP ;restore cursor location for passing to s.stdout
JSR s.stdout ;s.stdout MAY BE BREAKING THE CURSOR ARGUMENT FOR PASSING INTO s.takeIn THEREBY CAUSING THE STRANGE ONE-COMMAND-THEN-BREAK BUG
SET PC, s.instance.promptLoop

SET PC, POP
 ;
 
;:### s.takeIn (cursorPointer)
;:Writes a prompt to the screen using *v.sPrompt* and enters a loop to take ASCII input from the keyboard and write it to the screen at *cursorPointer*. It exits when the user presses `enter`.
;:
;:**returns** the cursor location on exit
;:
:s.takeIn
SET PUSH, I
SET I, 0

JSR sv.getNewLine ;get the next blank line after *cursorPointer*
JSR s.drawPrompt ;draw the prompt using s.drawPrompt

SET A, 1 ;HWI parameter

:s.takeIn.loop
IFL I, [v.promptLoc]
  SET I, [v.promptLoc]
SET [I], 0xf09e ;cursor character

:s.takeIn.wait
HWI [HW.GenericKeyboard] ;KEYBOARD HARDWARE DEVICE

IFG C, 0x1f
  IFL C, 0x80
    SET PC, s.takeIn.write

IFE C, 0x10
  SET PC, s.takeIn.backspace

IFE C, 0x11
  SET PC, s.takeIn.enter
SET PC, s.takeIn.wait


:s.takeIn.write
XOR C, 0xF000
STI [I], C

IFN I, [v.scrnEnd] ;write normally
  SET PC, s.takeIn.loop

:s.takeIn.write.scroll
SUB [v.promptLoc], [v.scrnWidth] ;make prompt scroll, too
JSR sv.scrollUp ;scroll everything up
SET PC, s.takeIn.loop


:s.takeIn.backspace
STD [I], 0
SET [I], 0
SET PC, s.takeIn.loop


:s.takeIn.enter
SET [I], 0
SET A, [v.promptLoc]
SET B, I
JSR s.stdin

SET A, I;return location in A
SET I, POP
SET PC, POP
 ;

;:### s.parse
;:It's not worth documenting this spaghetti code. It will be completely rewritten when *package* works.
;:

:s.parse
SET PUSH, I
SET I, [v.stdin]
SET A, v.cmdmem
SET [A], 1
SET B, 0x1F ;last five bits

:s.parse.trans
IFE [I], 0
  SET PC, s.parse.compare

SET C, B
AND C, [I]
MUL [A], C
ADD I, 1
SET PC, s.parse.trans


:s.parse.compare
AND [A], 0xFF
ADD [A], 0x900 ;MEMORY LOCATION

SET A, [A]
SET I, POP
IFE [A], 0 ;SHOULD EXIT WITH ERROR MESSAGE
  SET PC, exf
SET PC, [A] ;look up in table
 ;

;:### s.drawPrompt (pointer)
;:Draws a prompt using *env.cwds* and *v.sPrompt* at *pointer* and sets *v.promptLoc* to the location following the prompt.
;:
;:**returns** the location following the prompt
;:
:s.drawPrompt

SET C, A
SET A, env.cwds
SET B, 1
JSR typ.pUnpack

SET C, A
SET A, v.sPrompt
SET B, 1
JSR typ.pUnpack

SET [v.promptLoc], A

SET PC, POP
 ;

;:### s.stdin (startPointer, stopPointer)
;:Copies the values between *startPointer* and *stopPointer* to *v.stdin*.
;:
:s.stdin
SET PUSH, I
SET I, A
SET C, [v.stdin]

:s.stdin.loop
STI [C], [I]
AND [C], 0x007F
ADD C, 1

IFN I, B
  SET PC, s.stdin.loop

SET [C], 0
SET I, POP
SET PC, POP
 ;

;:### s.stdout (outputPointer)
;:Does a C-style copy from *v.stdout* to *outputPointer*.
:s.stdout
JSR sv.getNewLine

SET B, A ;output
SET A, [v.stdout] ;location
JSR typ.cCopy ;copy literally and null-terminated

SET PC, POP
 ;
 ;;
