;;;;;;;;;;;;;;;;;;
; KeyboardDaemon ;
;;;;;;;;;;;;;;;;;;
;:An instance of KeyboardDemon should be registered to any process that requires detection of keypresses. It requests an interrupt value from the operating system, and, when it detects that interrupt, writes the pressed key, if it is ASCII, to the location registered on its instantiation. (That location is, of course, incremented.)
;:

:kd.daemonlist
DAT 0 ;memory location containing four words per keyboard device
DAT 0 ;debug

:kd.length
DAT 0 ;number of literal words in the daemon list

;:## The Handler
;:All keyboards using KeyboardDaemon are given unique interrupt messages, all of which point *kd.keystroke*. 
;:
:kd.keystroke.int
                       ;when a .int enters, X is the interrupt message
SET B, X               ;word to find
SET A, [kd.daemonlist] ;pointer
JSR typ.ffw            ;find the word with this interrupt message,
                       ;to identify the calling keyboard

ADD A, [kd.daemonlist] ;make A a memory location rather than a length

IFE [A+0xfffe], 1   ;if keyboard is marked as not in use,
  SET PC, POP

SUB A, 1     ;make A a pointer to the port number
SET B, [A]   ;make B the port number
SET A, [A+2] ;make A the configuration location

SET PUSH, A
SET A, 1 ;get ASCII key in C
HWI B ;interrupt the port that triggered the interrupt

SET A, POP

IFE C, [A+3] ;if C is the exit character
  IFN [A+2], 0 ;if the notify location is not empty
    JSR [A+2] ;jump to "notify" location

IFE C, 0x91 ; If the key typed is Control.
    IFN [A+8], 0 ; If the notify location is not empty.
    	JSR [A+8] ; Jump to the Control handler.

IFG C, 0x1f ;if the key is an ASCII key
	SET PC, kd.checkASCII ;; Arrow keys ASCII codes are more than 0x1f, so we should check them, else we print the character.

IFE C, 0x10 ;backspace
  SET PC, kd.keystroke.backspace

SET PC, POP

:kd.checkASCII
IFG C, 0x7f
  IFL C, 0x84
    IFN [A+6], 0
      SET PC, [A+6]    ;; Arrow keys.

; Else:
SET PC, kd.keystroke.writeChar ;; I know this is not necessary as this function is down here. If you expand code in between here, it'll cause NULL pain.

:kd.keystroke.writeChar
SET B, [A+5] ;max onscreen position
IFE B, 0 ;if there is no max position specified
  SET B, 0xffff ;make B the highest possible value (no pointer)

IFL [A+1], B ;if the screen location is less than the maximum
  SET PC, kd.keystroke.writeChar.continue ;then continue

SET PC, POP ;otherwise, return

:kd.keystroke.writeChar.continue
SET PUSH, Y ;we're going to use Y to colorize 

SET B, [A] ;set B to the direct write location
SET [B], C ;write the ASCII key
ADD [A], 1 ;increase the pointer

SET B, [A+1]      ;set B to the screen write location
SET Y, [B+0xffff] ;set Y to the character before the screen write location
AND Y, 0xff80     ;make Y consist of only the effect characters

SET [B], C ;write C onscreen
BOR [B], Y ;colorize the onscreen character

ADD [A+1], 1 ;increase the onscreen write pointer

SET Y, POP
SET PC, POP

:kd.keystroke.backspace
IFG [A+1], [A+4] ;if the current screenpointer is at the minimum location
  SET PC, kd.keystroke.backspace.continue ;then continue

SET PC, POP ;otherwise, return

:kd.keystroke.backspace.continue
SUB [A], 1 ;decrement the direct write location
SET B, [A] ;make B the direct write location
SET [B], 0 ;erase the previous character

SUB [A+1], 1 ;decrement the screen write location
SET B, [A+1] ;make B the screen write location
SET [B], 0   ;erase the previous character

SET PC, POP


;:## Data Structures
;:The daemon list lives in the heap and is pointed to by a labelled word. It contains four words per keyboard, because each keyboard has four words associated with it as follows.
;:
;:### Daemon Instance Block
;:
;:```
;: +--------------
;: | %d size | use
;: +--------------
;: | 1 | is-active
;: | 1 | keyboard port
;: | 1 | keyboard interrupt message
;: | 1 | config block location
;: +--------------
;:```
;:
;:The first word in the block is a boolean **(1 or 2)** referring to the state of the keyboard. If it is 1, the keyboard is currently not in use. If it is 2, then it is currently acting as a source of input. The port is the DCPU-16 port that the keyboard is attached to. The keyboard interrupt message is the unique interrutp message given to the keyboard. The configuration block location is described below.
;:
;:### Option Block
;:
;:```
;: +----------------+
;: |  Direct Write  | <- the location at which to write the raw ascii
;: |  Screen Write  | <- the location at which to write the colorized ascii
;: | Notify On Exit | <- jumped to when "Exit Key" is pressed
;: |    Exit Key    |
;: |  Min-Position  | <- if 0, there is no minimum-position (onscreen)
;: |  Max-Position  | <- if 0, there is no maximum-position (onscreen)
;: |   Char Color   |
;: | Notify on Ctrl | <- jumped to when Control key is pressed.
;: |      ....      | <- Total length is 16 words
;: +----------------+
;:```
;:

;:### kd.init (slots)
;:Initializes the keyboard handler with enough room for *slots* many Generic Keyboard devices.
;:
:kd.init
MUL A, 4 ;multiply by 4, because each keyboard has 4 words associated with it
SET [kd.length], A
JSR heap.alloc ;
SET [kd.daemonlist], A
SET PC, POP
 ;

;:### kd.newKeyboard (GenericKeyboard)
;:Defines a new keyboard in the first open memory location carried by *kd.daemonlist*, as defined *kd.init*, or adds a new one if it doesn't exist.
;:
;:**returns** a pointer to the *GenericKeyboard*'s instance block, see below for use
;:The instance block is described above as the Daemon Instance Block. The value of the word that is returned is the bool (1 is FALSE and 2 is TRUE). In order for the daemon to react to keystrokes, this word must be set to 2. The options word should point to a valid options pointer, **first**, however.
;:
:kd.newKeyboard
SET B, [kd.daemonlist]
SET C, [kd.length]

ADD C, B ;make C the ending location of the list

:kd.newKeyboard.findexisting
IFE [B+1], A ;if the port exists ;TODO make this an actual search
  SET PC, kd.newKeyboard.found

ADD B, 4
IFL B, C ;C will point to the very last OptLoc, so we use IFL to be safe
  SET PC, kd.newKeyboard.findexisting

SET PUSH, A ;save the port
SET A, [kd.daemonlist] ;make A the location to search
JSR typ.ffz ;find the first zero
ADD A, [kd.daemonlist] ;typ.ffz adds the list

;SHOULD IMPOSE CHECK

SET C, A ;need to use C instead, here, so A isn't lost

SET [C], 1  ;set the "keyboard is active" bool to FALSE (2 is TRUE *IN THIS CASE*)

SET [C+1], POP ;add the new port
SET PUSH, C

SET A, kd.keystroke.int ;make the location to jump to the keystroke handler
JSR pih.newMsg ;make A a new interrupt message
SET C, POP

SET [C+2], A ;store the new message
SET [C+3], 0xffff ;set the next word to 0xffff, so it's skipped in the search, just in case

SET B, A ;put the message in B for the hardware call

SET A, 3    ;hardware call to enable interrupts with message in B
HWI [C+1]  ;interrupt the GenericKeyboard port

SET B, C    ;set B to the first word of the keyboard instance's block
            ;for easy handling below

:kd.newKeyboard.found
SET A, B
;A is the first word of the keyboard's instance block, so return that
SET PC, POP


