;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TASKER ; Process Manager ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:v.tusk.IDiterator DAT 1000 ;the iterator through which to get unique IDs
:v.tusk.runPID DAT 0 ;the ID of the process that is currently running

:v.tusk.PIDloc DAT tusk.PIDs
:v.tusk.memStack DAT 0 ;should be replaced with a file or heapspace
                       ;carrying a bunch of pointers to memstacks

;:### tusk.newProcess
;:Registers a new process of unique ID. <strike>Adds the process id to the table at *v.tusk.PIDloc*.</strike>
;:
;:**under development**
;:
:tusk.newProcess
SET PUSH, A
SET PUSH, B
SET PUSH, C

SET [v.tusk.runPID], [v.tusk.IDiterator] ;change to the new process
ADD [v.tusk.IDiterator], 1 ;increase iterator by 1

SET A, 0x40 ;reserve enough space for 31 memory slots (2 words per slot)
JSR heap.alloc

SET B, A
ADD B, 1 ;make B the index after A

SET [A], B ;make the first word in the memstack its stack pointer

SET [v.tusk.memStack], A
SET Y, [v.tusk.memStack] ;debug

SET C, POP
SET B, POP
SET A, POP
SET PC, POP

;:### tusk.getMem (length)
;:Reserves a *length* amount of memory from the heap using *heap.alloc*<strike>, such that the memory will be freed when the process terminates.</strike>
;:
;:**modifies** A
;:**returns** the first location of the reserved memory
;:
:tusk.getMem
SET PUSH, B
SET PUSH, C
;SET PUSH, Y ;for the stack pointer
;SET PUSH, X ;for the location the stack pointer is at
;SET Y, SP

;SET X, [v.tusk.memStack]
;SET SP, [X] ;recover from the stack pointer
;SET Z, SP

;SET PUSH, A ;push length to the memstack
JSR heap.alloc
;SET PUSH, A ;push location to the memstack

;SET [X], SP ;update the stack pointer carrier

;SET SP, Y
;SET X, POP
;SET Y, POP
SET C, POP
SET B, POP
SET PC, POP

;:### tusk.dropMem ()

:tusk.PIDs ;64 open spaces
DAT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
